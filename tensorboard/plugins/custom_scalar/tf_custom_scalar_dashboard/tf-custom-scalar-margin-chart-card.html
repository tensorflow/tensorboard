<!--
@license
Copyright 2017 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../iron-collapse/iron-collapse.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-menu/paper-menu.html">
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../tf-backend/tf-backend.html">
<link rel="import" href="../tf-line-chart-data-loader/tf-line-chart-data-loader.html">
<link rel="import" href="../tf-card-heading/tf-card-heading.html">
<link rel="import" href="../tf-color-scale/tf-color-scale.html">
<link rel="import" href="tf-custom-scalar-card-style.html">

<!--
  A card that handles loading data (at the right times), rendering a scalar
  chart, and providing UI affordances (such as buttons) for scalar data.
-->
<dom-module id="tf-custom-scalar-margin-chart-card">
<template>
  <h1>[[_titleDisplayString]]</h1>
  <div id="tf-line-chart-data-loader-container">
    <tf-line-chart-data-loader
      x-type="[[xType]]"
      x-components-creation-method="[[_xComponentsCreationMethod]]"
      smoothing-enabled="[[smoothingEnabled]]"
      smoothing-weight="[[smoothingWeight]]"
      tooltip-sorting-method="[[tooltipSortingMethod]]"
      ignore-y-outliers="[[ignoreYOutliers]]"
      request-manager="[[requestManager]]"
      runs="[[runs]]"
      tag="[[_tagFilter]]"
      active="[[active]]"
      data-url="[[_dataUrl]]"
      log-scale-active="[[_logScaleActive]]"
      process-data="[[_createProcessDataFunction(marginChartSeries)]]"
      color-scale="[[_colorScale]]"
      data-series="[[_dataSeriesStrings]]"
      symbol-function="[[_createSymbolFunction()]]"
      tooltip-columns="[[_tooltipColumns]]"
      fill-area="[[_fillArea]]"
    >
    </tf-line-chart-data-loader>
  </div>
  <div id="buttons">
    <paper-icon-button
      selected$="[[_expanded]]"
      icon="fullscreen"
      on-tap="_toggleExpanded"
    ></paper-icon-button>
    <paper-icon-button
      selected$="[[_logScaleActive]]"
      icon="line-weight"
      on-tap="_toggleLogScale"
      title="Toggle y-axis log scale"
    ></paper-icon-button>
    <paper-icon-button
      icon="settings-overscan"
      on-tap="_resetDomain"
      title="Fit domain to data"
    ></paper-icon-button>
    <span style="flex-grow: 1"></span>
    <template is="dom-if" if="[[showDownloadLinks]]">
      <div class="download-links">
        <paper-dropdown-menu
          no-label-float="true"
          label="series to download"
          selected-item-label="{{_dataSeriesNameToDownload}}"
        >
          <paper-menu class="dropdown-content" slot="dropdown-content">
            <template is="dom-repeat" items="[[_dataSeriesStrings]]" as="dataSeriesName">
              <paper-item no-label-float=true>[[dataSeriesName]]</paper-item>
            </template>
          </paper-menu>
        </paper-dropdown-menu>
        <a
          download="[[_dataSeriesNameToDownload]].csv"
          href="[[_csvUrl(_nameToDataSeries, _dataSeriesNameToDownload)]]"
        >CSV</a> <a
          download="[[_dataSeriesNameToDownload]].json"
          href="[[_jsonUrl(_nameToDataSeries, _dataSeriesNameToDownload)]]"
        >JSON</a>
      </div>
    </template>
  </div>

  <template is="dom-if" if="[[_tagsWithNoData]]">
    <div id="error-content">
      <iron-icon class="error-icon" icon="icons:error"></iron-icon>
      No data found for these tags:
      <ul>
        <template is="dom-repeat" items="[[_tagsWithNoData]]">
          <li>[[item]]</li>
        </template>
      </ul>
      <br>
      Tags for the value, lower, and upper bounds of margin charts in the Layout
      proto must match tags in the SCALARS dashboard.
    </div>
  </template>

  <template is="dom-if" if="[[_tagFilterInvalid]]">
    <div id="error-content">
      <iron-icon class="error-icon" icon="icons:error"></iron-icon>
      [[_tagFilter]] is an invalid regular expression.
    </div>
  </template>

  <template is="dom-if" if="[[_stepsMismatch]]">
    <div id="error-content">
      <iron-icon class="error-icon" icon="icons:error"></iron-icon>
      The steps for value, lower, and upper tags do not match:
      <ul>
        <li>
          <span class="tag-name">[[_stepsMismatch.seriesObject.value]]</span>:
          [[_separateWithCommas(_stepsMismatch.valueSteps)]]
        </li>
        <li>
          <span class="tag-name">[[_stepsMismatch.seriesObject.lower]]</span>:
          [[_separateWithCommas(_stepsMismatch.lowerSteps)]]
        </li>
        <li>
          <span class="tag-name">[[_stepsMismatch.seriesObject.upper]]</span>:
          [[_separateWithCommas(_stepsMismatch.upperSteps)]]
        </li>
      </ul>
    </div>
  </template>
  
  <div id="matches-container">
    <div id="matches-list-title">
      <template is="dom-if" if="[[_dataSeriesStrings.length]]">
        <paper-icon-button
          icon="[[_getToggleMatchesIcon(_matchesListOpened)]]"
          on-click="_toggleMatchesOpen"
          class="toggle-matches-button">
        </paper-icon-button>
      </template>

      <span class="matches-text">
        Matches ([[_dataSeriesStrings.length]])
      </span>
    </div>
    <template is="dom-if" if="[[_dataSeriesStrings.length]]">
      <iron-collapse opened="[[_matchesListOpened]]">
        <div id="matches-list">
          <template is="dom-repeat"
                    items="[[_dataSeriesStrings]]"
                    as="seriesName">
              <div class="match-list-entry"
                   style="color: [[_determineColor(_colorScale, seriesName)]];">
                <span class="match-entry-symbol">
                  [[_determineSymbol(_nameToDataSeries, seriesName)]]
                </span>
                [[seriesName]]
              </div>
          </template>
        </div>
      </iron-collapse>
    </template>
  </div>

  </div>
  <style include="tf-custom-scalar-card-style"></style>
  <style>
    #error-content {
      background: #f00;
      border-radius: 5px;
      color: #fff;
      margin: 10px 0 0 0;
      padding: 10px;
    }

    .error-icon {
      fill: #fff;
    }

    #error-content ul {
      margin: 1px 0 0 0;
      padding: 0 0 0 19px;
    }

    .tag-name {
      font-weight: bold;
    }

    #matches-list-title {
      margin: 10px 0 5px 0;
    }

    #matches-list {
      font-size: 0.8em;
      max-height: 200px;
      overflow-y: auto;
    }

    .match-list-entry {
      margin: 0 0 5px 0;
    }

    .match-entry-symbol {
      font-family: arial, sans-serif;
      display: inline-block;
      width: 10px;
    }

    .matches-text {
      vertical-align: middle;
    }
  </style>
</template>
<script src='tf-custom-scalar-helpers.js'></script>
<script>
  Polymer({
      is: 'tf-custom-scalar-margin-chart-card',
      properties: {
        runs: Array,  // of String

        /**
         * This property must take on values from the XType enum defined within
         * the vz_line_chart component.
         */
        xType: String,

        active: {
          type: Boolean,
          value: true,
          readOnly: true,
        },
        title: String,
        // An array of JSON objects that represent MarginChartContent.Series
        // protos. The properties of these series differ from those of data
        // series used by the tf-line-chart-data-loader component.
        marginChartSeries: Array,
        ignoreYOutliers: Boolean,
        requestManager: Object,
        showDownloadLinks: Boolean,
        smoothingEnabled: Boolean,
        smoothingWeight: Number,
        tagMetadata: Object,
        tooltipSortingMethod: String,

        // We use a special color scale that wraps the run-based one.
        _colorScale: {
          type: Object,
          value: new tf_custom_scalar_dashboard.DataSeriesColorScale({scale: tf_color_scale.runsColorScale}),
          readOnly: true,
        },

        /**
         * A regular expression to use for matching tags.
         */
        _tagFilter: {
          type: String,
          computed: '_computeTagFilter(marginChartSeries)',
        },

        /**
         * Whether the tag filter was deemed to be invalid.
         */
        _tagFilterInvalid: Boolean,

        /**
         * Maps from the name of the data series to the DataSeries object.
         */
        _nameToDataSeries: {
          type: Object,
          value: {},
        },

        /**
         * A mapping between selected runs (strings) to the value 1. This is
         * effectively a set of strings.
         */
        _selectedRunsSet: {
          type: Object,
          computed: '_computeSelectedRunsSet(runs)',
        },
        _dataSeriesStrings: {
          type: Array,
          computed: '_computeDataSeriesStrings(_selectedRunsSet, _nameToDataSeries)',
        },
        _dataSeriesObjects: {
          type: Array,
          computed: '_computeDataSeriesObjects(_nameToDataSeries, _dataSeriesStrings)',
        },
        _expanded: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,  // for CSS
        },
        _logScaleActive: Boolean,
        _dataUrl: {
          type: Function,
          value: () => (tag, run) => tf_backend.addParams(
              tf_backend.getRouter().pluginRoute(
                  'custom_scalars', '/scalars'), {tag, run}),
        },
        _xComponentsCreationMethod: {
          type: Object,
          computed: '_computeXComponentsCreationMethod(xType)',
        },
        /**
         * A mapping from run to the next available symbol for that run. We use
         * symbols to differentiate data series within the same run.
         */
        _runToNextAvailableSymbolIndex: {
          type: Object,
          value: {},
        },
        _matchesListOpened: {
          type: Boolean,
          value: false,
        },
        _titleDisplayString: {
          type: String,
          computed: '_computeTitleDisplayString(title, _tagFilter)',
        },
        _fillArea: {
          type: Object,
          readOnly: true,
          value: {
              lowerAccessor: d => d.lower,
              higherAccessor: d => d.upper,
          },
        },
        _tooltipColumns: {
          type: Array,
          value: function() {
            const valueFormatter = vz_line_chart.multiscaleFormatter(
                vz_line_chart.Y_TOOLTIP_FORMATTER_PRECISION);
            const formatValueOrNaN =
                (x) => isNaN(x) ? 'NaN' : valueFormatter(x);

            return [
              {
                title: 'Name',
                evaluate: (d) => d.dataset.metadata().name,
              },
              {
                title: 'Smoothed',
                evaluate: (d, statusObject) => formatValueOrNaN(
                    statusObject.smoothingEnabled ? d.datum.smoothed :
                                                    d.datum.scalar),
              },
              {
                title: 'Value',
                evaluate: (d) => formatValueOrNaN(d.datum.scalar),
              },
              {
                title: 'Lower Margin',
                evaluate: (d) => formatValueOrNaN(d.datum.lower),
              },
              {
                title: 'Upper Margin',
                evaluate: (d) => formatValueOrNaN(d.datum.upper),
              },
              {
                title: 'Step',
                evaluate: (d) => vz_line_chart.stepFormatter(d.datum.step),
              },
              {
                title: 'Time',
                evaluate: (d) => vz_line_chart.timeFormatter(d.datum.wall_time),
              },
              {
                title: 'Relative',
                evaluate: (d) => vz_line_chart.relativeFormatter(
                    vz_line_chart.relativeAccessor(d.datum, -1, d.dataset)),
              },
            ];
          }
        },
        _tagsWithNoData: String,
        /**
         * This field is only set if data retrieved from the server exhibits a
         * step mismatch: if the lists of values, lower bounds, and upper bounds
         * do not match in step. If set, this object has these properties:
         * 
         * seriesObject: An object that represents a MarginChartContent.Series
         *     proto.
         * valueSteps: A list of steps (numbers) for the values.
         * lowerSteps: A list of steps (numbers) for the lower bounds.
         * upperSteps: A list of steps (numbers) for the upper bounds.
         */
        _stepsMismatch: Object,
      },
      observers: [
        '_updateChart(_nameToDataSeries)',
        // Clear the data series when the tag filter changes.
        '_refreshDataSeries(_tagFilter)',
      ],
      reload() {
        this.$$('tf-line-chart-data-loader').reload();
      },
      redraw() {
        this.$$('tf-line-chart-data-loader').redraw();
      },
      _toggleExpanded(e) {
        this.set('_expanded', !this._expanded);
        this.redraw();
      },
      _toggleLogScale() {
        this.set('_logScaleActive', !this._logScaleActive);
      },
      _resetDomain() {
        const chart = this.$$('tf-line-chart-data-loader');
        if (chart) {
          chart.resetDomain();
        }
      },
      _csvUrl(nameToDataSeries, dataSeriesName) {
        const baseUrl = this._downloadDataUrl(nameToDataSeries, dataSeriesName);
        return tf_backend.addParams(baseUrl, {format: 'csv'});
      },
      _jsonUrl(nameToDataSeries, dataSeriesName) {
        const baseUrl = this._downloadDataUrl(nameToDataSeries, dataSeriesName);
        return tf_backend.addParams(baseUrl, {format: 'json'});
      },
      _downloadDataUrl(nameToDataSeries, dataSeriesName) {
        const dataSeries = nameToDataSeries[dataSeriesName];
        const getVars = {
            tag: dataSeries.getTag(),
            run: dataSeries.getRun(),
        };
        return tf_backend.addParams(
              tf_backend.getRouter().pluginRoute(
                  'custom_scalars', '/download_data'), getVars);
      },
      _computeXComponentsCreationMethod(xType) {
        return () => vz_line_chart.getXComponents(xType);
      },
      _createProcessDataFunction(marginChartSeries) {
        // This function is called when data is received from the backend.
        return ((scalarChart, run, data) => {
          if (!data.regex_valid) {
            // The regular expression is constructed from frontend logic that
            // pieces together different tags. Hence, this case should never be
            // reached if the dashboard behaves correctly.
            this.set('_tagFilterInvalid', true);
            return;
          }

          // The user's regular expression was valid.
          // Incorporate these newly loaded values.
          const newMapping = _.clone(this._nameToDataSeries);
          const tagsNotFound = [];
          _.forEach(marginChartSeries, tagsObject => {
            let tagNotFound = false;
            const scalarEvents = data.tag_to_events[tagsObject.value];
            const lowerBounds = data.tag_to_events[tagsObject.lower];
            const upperBounds = data.tag_to_events[tagsObject.upper];

            // Make sure that data is found for each of the tags.
            if (_.isUndefined(scalarEvents)) {
              tagsNotFound.push(tagsObject.value);
              tagNotFound = true;
            }
            if (_.isUndefined(lowerBounds)) {
              tagsNotFound.push(tagsObject.lower);
              tagNotFound = true;
            }
            if (_.isUndefined(upperBounds)) {
              tagsNotFound.push(tagsObject.upper);
              tagNotFound = true;
            }

            // At least one of the tags lacks data. We terminate early because
            // the line chart requires all 3 pieces of data (value, lower bound,
            // and upper bound).
            if (tagNotFound) {
              return;
            }

            // Make sure that steps for all the lists correspond with each
            // other. Otherwise, display an error message.
            const obtainStep = datum => datum[1];
            const stepsMismatch = this._findStepMismatch(
                tagsObject,
                dataPoints.map(obtainStep),
                lowerBounds.map(obtainStep),
                upperBounds.map(obtainStep));
            if (stepsMismatch) {
              this.set('_stepsMismatch', stepsMismatch);
            }

            // Create data points that the line chart can parse.
            const dataPoints = scalarEvents.map(datum => ({
              wall_time: new Date(datum[0] * 1000),
              step: obtainStep(datum),
              scalar: datum[2],
            }));

            // Compute the series name, which is based on both the run and the
            // tag of the value.
            const seriesName =
                tf_custom_scalar_dashboard.generateDataSeriesName(
                    run, tagsObject.value);
            let series = newMapping[seriesName];

            if (series) {
              // This series already exists.
              series.setData(dataPoints);
            } else {
              this._createNewDataSeries(
                  run, tagsObject.value, seriesName, dataPoints);
            }
          });

          if (tagsNotFound.length) {
            // At least 1 tag could not be found. Show an error message.
            this.set('_tagsWithNoData', tagsNotFound);
            return;
          }

          this.set('_nameToDataSeries', newMapping);
        });
      },
      _findStepMismatch(tagsObject, valueSteps, lowerSteps, upperSteps) {
        if (lowerBounds.length != valueSteps.length ||
            upperBounds.length != valueSteps.length) {
          return {
            seriesObject: tagsObject,
            valueSteps: valueSteps,
            lowerSteps: lowerSteps,
            upperSteps: upperSteps,
          };
        }
        for (let i = 0; i < valueSteps.length; i++) {
          if (valueSteps[i] != lowerSteps[i] ||
              valueSteps[i] != upperSteps[i]) {
            return {
              seriesObject: tagsObject,
              valueSteps: valueSteps,
              lowerSteps: lowerSteps,
              upperSteps: upperSteps,
            };
          }
        }
        return null;
      },
      _createNewDataSeries(run, tag, seriesName, dataPoints) {
        // If the run has not been seen before, define the next
        // available marker index.
        this._runToNextAvailableSymbolIndex[run] |= 0;

        // Every data series within a run has a unique symbol.
        const lineChartSymbol = vz_line_chart.SYMBOLS_LIST[
            this._runToNextAvailableSymbolIndex[run]];

        // Create a series with this name.
        series = new tf_custom_scalar_dashboard.DataSeries(
            run, tag, seriesName, dataPoints, lineChartSymbol);
        newMapping[seriesName] = series;

        // Loop back to the beginning if we are out of symbols.
        const numSymbols = vz_line_chart.SYMBOLS_LIST.length;
        this._runToNextAvailableSymbolIndex[run] =
            (this._runToNextAvailableSymbolIndex[run] + 1) % numSymbols;
      },
      _updateChart(nameToDataSeries) {
        // Add new data series.
        _.forOwn(nameToDataSeries, dataSeries => {
          this.$$('tf-line-chart-data-loader').setSeriesData(
              dataSeries.getName(), dataSeries.getData());
        });
      },
      _computeSelectedRunsSet(runs) {
        const mapping = {};
        _.forEach(runs, run => {
          mapping[run] = 1;
        });
        return mapping;
      },
      _computeDataSeriesStrings(selectedRunsSet, nameToDataSeries) {
        return _.values(nameToDataSeries)
            .filter(series => selectedRunsSet[series.getRun()])
            .map(series => series.getName());
      },
      _computeDataSeriesObjects(nameToDataSeries, dataSeriesStrings) {
        return dataSeriesStrings.map(
            seriesName => nameToDataSeries[seriesName]);
      },
      _determineColor(colorScale, seriesName) {
        return colorScale.scale(seriesName);
      },
      _refreshDataSeries(_tagFilter) {
        this.set('_nameToDataSeries', {});
      },
      _createSymbolFunction() {
        return seriesName => (
            this._nameToDataSeries[seriesName].getSymbol().method());
      },
      _determineSymbol(nameToDataSeries, seriesName) {
        return nameToDataSeries[seriesName].getSymbol().character;
      },
      _computeTagFilter(marginChartSeries) {
        const tags = _.flatten(
            marginChartSeries.map(
                series => [series.value, series.lower, series.upper]));
        const escapedTags = tags.map(
            r => '(' + this._escapeRegexCharacters(r) + ')');
        // Combine the different regexes into a single regex.
        return escapedTags.join('|');
      },
      _escapeRegexCharacters(stringValue) {
        return stringValue.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      },
      _getToggleMatchesIcon(matchesListOpened) {
        return matchesListOpened ? 'expand-less' : 'expand-more';
      },
      _toggleMatchesOpen() {
        this.set('_matchesListOpened', !this._matchesListOpened);
      },
      _computeTitleDisplayString(title, tagFilter) {
        // If no title is provided, use the tag filter, which is a combination
        // of the tags for the value, lower, and upper fields.
        return title || tagFilter;
      },
      _separateWithCommas(numbers) {
        return numbers.join(', ');
      },
  });
</script>
</dom-module>
