/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
var tf;
(function (tf) {
    var graph;
    (function (graph) {
        var scene;
        (function (scene) {
            var node;
            (function (node_1) {
                /**
                 * Select or Create a 'g.nodes' group to a given sceneGroup
                 * and builds a number of 'g.node' groups inside the group.
                 *
                 * Structure Pattern:
                 *
                 * <g class='nodes'>
                 *   <g class='node'>
                 *     <g class='in-annotations'>
                 *       ...
                 *     </g>
                 *     <g class='out-annotations'>
                 *       ...
                 *     </g>
                 *     <g class='nodeshape'>
                 *      <!--
                 *      Content of the node shape should be for the node itself. For example a
                 *      Metanode would have a <rect> with rounded edges, an op would have an
                 *      <ellipse>. More complex nodes like series may contain multiple
                 *      elements which are conditionally visible based on whether the node is
                 *      expanded.
                 *      -->
                 *     </g>
                 *     <text class='label'>node name</text>
                 *     <g class='subscene'>
                 *       <!--
                 *       Content of  the subscene (only for metanode and series node).
                 *
                 *       Subscene is a svg group that contains content of the
                 *       metanode's metagraph that is recursively generated by Scene.build().
                 *
                 *       When the graph is expanded multiple times, a subscene can contain
                 *       nested subscenes inside.
                 *       -->
                 *     </g>
                 *   </g>
                 *   ...
                 * </g>
                 *
                 *
                 * @param sceneGroup selection of the container
                 * @param nodeData array of render node information to map
                 * @param sceneElement <tf-graph-scene> polymer element
                 * @return selection of the created nodeGroups
                 */
                function buildGroup(sceneGroup, nodeData, sceneElement) {
                    var container = scene.selectOrCreateChild(sceneGroup, 'g', scene.Class.Node.CONTAINER);
                    // Select all children and join with data.
                    // (Note that all children of g.nodes are g.node)
                    var nodeGroups = container.selectAll(function () { return this.childNodes; })
                        .data(nodeData, function (d) {
                        // make sure that we don't have to swap shape type
                        return d.node.name + ':' + d.node.type;
                    });
                    // ENTER
                    nodeGroups.enter()
                        .append('g')
                        .attr('data-name', function (d) { return d.node.name; })
                        .each(function (d) {
                        var nodeGroup = d3.select(this);
                        // index node group for quick stylizing
                        sceneElement.addNodeGroup(d.node.name, nodeGroup);
                    })
                        .merge(nodeGroups)
                        .attr('class', function (d) { return scene.Class.Node.GROUP + ' ' + nodeClass(d); })
                        .each(function (d) {
                        var nodeGroup = d3.select(this);
                        // Add g.in-annotations (always add -- to keep layer order
                        // consistent.)
                        var inAnnotationBox = scene.selectOrCreateChild(nodeGroup, 'g', scene.Class.Annotation.INBOX);
                        scene.annotation.buildGroup(inAnnotationBox, d.inAnnotations, d, sceneElement);
                        // Add g.out-annotations  (always add -- to keep layer order
                        // consistent.)
                        var outAnnotationBox = scene.selectOrCreateChild(nodeGroup, 'g', scene.Class.Annotation.OUTBOX);
                        scene.annotation.buildGroup(outAnnotationBox, d.outAnnotations, d, sceneElement);
                        // Build .shape first (background of the node).
                        var shape = buildShape(nodeGroup, d, scene.Class.Node.SHAPE);
                        if (d.node.isGroupNode) {
                            addButton(shape, d, sceneElement);
                        }
                        addInteraction(shape, d, sceneElement);
                        // Build subscene on the top.
                        subsceneBuild(nodeGroup, d, sceneElement);
                        // Build label last. Should be on top of everything else.
                        var label = labelBuild(nodeGroup, d, sceneElement);
                        // Do not add interaction to metanode labels as they live inside the
                        // metanode shape which already has the same interactions.
                        addInteraction(label, d, sceneElement, d.node.type === graph.NodeType.META);
                        stylize(nodeGroup, d, sceneElement);
                        position(nodeGroup, d);
                    });
                    // EXIT
                    nodeGroups.exit()
                        .each(function (d) {
                        // remove all indices on remove
                        sceneElement.removeNodeGroup(d.node.name);
                        var nodeGroup = d3.select(this);
                        if (d.inAnnotations.list.length > 0) {
                            nodeGroup.select('.' + scene.Class.Annotation.INBOX)
                                .selectAll('.' + scene.Class.Annotation.GROUP)
                                .each(function (a) { sceneElement.removeAnnotationGroup(a, d); });
                        }
                        if (d.outAnnotations.list.length > 0) {
                            nodeGroup.select('.' + scene.Class.Annotation.OUTBOX)
                                .selectAll('.' + scene.Class.Annotation.GROUP)
                                .each(function (a) { sceneElement.removeAnnotationGroup(a, d); });
                        }
                    })
                        .remove();
                    return nodeGroups;
                }
                node_1.buildGroup = buildGroup;
                ;
                /**
                 * Update or remove the subscene of a render group node depending on whether it
                 * is a expanded. If the node is not a group node, this method has no effect.
                 *
                 * @param nodeGroup selection of the container
                 * @param renderNodeInfo the render information for the node.
                 * @param sceneElement <tf-graph-scene> polymer element.
                 * @return Selection of the subscene group, or null if node group does not have
                 *        a subscene. Op nodes, bridge nodes and unexpanded group nodes will
                 *        not have a subscene.
                 */
                function subsceneBuild(nodeGroup, renderNodeInfo, sceneElement) {
                    if (renderNodeInfo.node.isGroupNode) {
                        if (renderNodeInfo.expanded) {
                            // Recursively build the subscene.
                            return scene.buildGroup(nodeGroup, renderNodeInfo, sceneElement, scene.Class.Subscene.GROUP);
                        }
                        // Clean out existing subscene if the node is not expanded.
                        scene.selectChild(nodeGroup, 'g', scene.Class.Subscene.GROUP).remove();
                    }
                    return null;
                }
                ;
                /**
                 * Translate the subscene of the given node group
                 */
                function subscenePosition(nodeGroup, d) {
                    var x0 = d.x - d.width / 2.0 + d.paddingLeft;
                    var y0 = d.y - d.height / 2.0 + d.paddingTop;
                    var subscene = scene.selectChild(nodeGroup, 'g', scene.Class.Subscene.GROUP);
                    scene.translate(subscene, x0, y0);
                }
                ;
                /**
                 * Add an expand/collapse button to a group node
                 *
                 * @param selection The group node selection.
                 * @param d Info about the node being rendered.
                 * @param sceneElement <tf-graph-scene> polymer element.
                 */
                function addButton(selection, d, sceneElement) {
                    var group = scene.selectOrCreateChild(selection, 'g', scene.Class.Node.BUTTON_CONTAINER);
                    scene.selectOrCreateChild(group, 'circle', scene.Class.Node.BUTTON_CIRCLE);
                    scene.selectOrCreateChild(group, 'path', scene.Class.Node.EXPAND_BUTTON)
                        .attr('d', 'M0,-2.2 V2.2 M-2.2,0 H2.2');
                    scene.selectOrCreateChild(group, 'path', scene.Class.Node.COLLAPSE_BUTTON)
                        .attr('d', 'M-2.2,0 H2.2');
                    group.on('click', function (d) {
                        // Stop this event's propagation so that it isn't also considered a
                        // node-select.
                        d3.event.stopPropagation();
                        sceneElement.fire('node-toggle-expand', { name: d.node.name });
                    });
                    scene.positionButton(group, d);
                }
                ;
                /**
                 * Fire node-* events when the selection is interacted.
                 *
                 * @param disableInteraction When true, have the provided selection
                 * ignore all pointer events. Used for text labels inside of metanodes, which
                 * don't need interaction as their surrounding shape has interaction, and if
                 * given interaction would cause conflicts with the expand/collapse button.
                 */
                function addInteraction(selection, d, sceneElement, disableInteraction) {
                    if (disableInteraction) {
                        selection.attr('pointer-events', 'none');
                        return;
                    }
                    var contextMenuFunction = scene.contextmenu.getMenu(getContextMenu(d.node, sceneElement));
                    selection
                        .on('dblclick', function (d) {
                        sceneElement.fire('node-toggle-expand', { name: d.node.name });
                    })
                        .on('mouseover', function (d) {
                        // don't send mouseover over expanded group,
                        // otherwise it is causing too much glitches
                        if (sceneElement.isNodeExpanded(d)) {
                            return;
                        }
                        sceneElement.fire('node-highlight', { name: d.node.name });
                    })
                        .on('mouseout', function (d) {
                        // don't send mouseover over expanded group,
                        // otherwise it is causing too much glitches
                        if (sceneElement.isNodeExpanded(d)) {
                            return;
                        }
                        sceneElement.fire('node-unhighlight', { name: d.node.name });
                    })
                        .on('click', function (d) {
                        // Stop this event's propagation so that it isn't also considered
                        // a graph-select.
                        d3.event.stopPropagation();
                        sceneElement.fire('node-select', { name: d.node.name });
                    })
                        .on('contextmenu', function (d, i) {
                        sceneElement.fire('node-select', { name: d.node.name });
                        contextMenuFunction.call(d, i);
                    });
                }
                ;
                /**
                 * Returns the d3 context menu specification for the provided node.
                 */
                function getContextMenu(node, sceneElement) {
                    var menu = [{
                            title: function (d) {
                                return graph.getIncludeNodeButtonString(node.include);
                            },
                            action: function (elm, d, i) {
                                sceneElement.fire('node-toggle-extract', { name: node.name });
                            }
                        }];
                    if (sceneElement.nodeContextMenuItems) {
                        // Add these additional context menu items.
                        menu = menu.concat(sceneElement.nodeContextMenuItems);
                    }
                    if (canBeInSeries(node)) {
                        menu.push({
                            title: function (d) { return getGroupSettingLabel(node); },
                            action: function (elm, d, i) {
                                sceneElement.fire('node-toggle-seriesgroup', { name: getSeriesName(node) });
                            }
                        });
                    }
                    return menu;
                }
                node_1.getContextMenu = getContextMenu;
                /** Returns if a node can be part of a grouped series */
                function canBeInSeries(node) {
                    return getSeriesName(node) !== null;
                }
                node_1.canBeInSeries = canBeInSeries;
                /**
                 * Returns the name of the possible grouped series containing this node.
                 * Returns null if the node cannot be part of a grouped series of nodes.
                 */
                function getSeriesName(node) {
                    if (!node) {
                        return null;
                    }
                    if (node.type === graph.NodeType.SERIES) {
                        return node.name;
                    }
                    if (node.type === graph.NodeType.OP) {
                        var op_1 = node;
                        return op_1.owningSeries;
                    }
                    return null;
                }
                node_1.getSeriesName = getSeriesName;
                /**
                 * Returns the SeriesNode that represents the series that the provided node
                 * is contained in (or itself if the provided node is itself a SeriesNode).
                 * Returns null if the node is not rendered as part of a series.
                 */
                function getContainingSeries(node) {
                    var s = null;
                    if (!node) {
                        return null;
                    }
                    else if (node.type === graph.NodeType.SERIES) {
                        s = node;
                    }
                    else if (node.parentNode && node.parentNode.type === graph.NodeType.SERIES) {
                        s = node.parentNode;
                    }
                    return s;
                }
                /**
                 * Returns the label for a button to toggle the group setting of the provided
                 * node.
                 */
                function getGroupSettingLabel(node) {
                    return tf.graph.getGroupSeriesNodeButtonString(getContainingSeries(node) !== null ? tf.graph.SeriesGroupingType.GROUP :
                        tf.graph.SeriesGroupingType.UNGROUP);
                }
                node_1.getGroupSettingLabel = getGroupSettingLabel;
                /**
                 * Append svg text for label and assign data.
                 * @param nodeGroup
                 * @param renderNodeInfo The render node information for the label.
                 * @param sceneElement <tf-graph-scene> polymer element.
                 */
                function labelBuild(nodeGroup, renderNodeInfo, sceneElement) {
                    var text = renderNodeInfo.displayName;
                    // Truncate long labels for unexpanded Metanodes.
                    var useFontScale = renderNodeInfo.node.type === graph.NodeType.META &&
                        !renderNodeInfo.expanded;
                    var label = scene.selectOrCreateChild(nodeGroup, 'text', scene.Class.Node.LABEL);
                    // Make sure the label is visually on top among its siblings.
                    var labelNode = label.node();
                    labelNode.parentNode.appendChild(labelNode);
                    label.attr('dy', '.35em').attr('text-anchor', 'middle');
                    if (useFontScale) {
                        if (text.length > sceneElement.maxMetanodeLabelLength) {
                            text = text.substr(0, sceneElement.maxMetanodeLabelLength - 2) + '...';
                        }
                        var scale = getLabelFontScale(sceneElement);
                        label.attr('font-size', scale(text.length) + 'px');
                    }
                    var txtElement = label.text(text);
                    enforceLabelWidth(txtElement, renderNodeInfo.node.type, renderNodeInfo);
                    return label;
                }
                /**
                 * This function shortens text which would exceed the maximum pixel width of
                 * a label.
                 *
                 * @param txtElementSelection The text element containing the label's text as d3
                 * selection.
                 * @param nodeType The type of the node the label belongs to. If the node is
                 * an annotation, the value is -1. Label widths are defined in
                 * layout.PARAMS.nodeSize.{meta|op|...}.maxLabelWidth for nodes and
                 * layout.PARAMS.annotations.labelWidth for annotations.
                 * @param renderNodeInfo The render information about the node, required to
                 * determine whether META nodes are collapsed or expanded.
                 */
                function enforceLabelWidth(txtElementSelection, nodeType, renderNodeInfo) {
                    // Get text element itself and its on-screen width.
                    var txtNode = txtElementSelection.node();
                    var computedTxtLength = txtNode.getComputedTextLength();
                    var labelContent = txtNode.textContent;
                    // Get maximum length from settings.
                    var maxLength = null;
                    switch (nodeType) {
                        case graph.NodeType.META:
                            if (renderNodeInfo && !renderNodeInfo.expanded) {
                                // node expanded.
                                maxLength = graph.layout.PARAMS.nodeSize.meta.maxLabelWidth;
                            }
                            break;
                        case graph.NodeType.OP:
                            maxLength = graph.layout.PARAMS.nodeSize.op.maxLabelWidth;
                            break;
                        case -1:
                            maxLength = graph.layout.PARAMS.annotations.maxLabelWidth;
                            break;
                        default:
                            break;
                    }
                    // Return if no max length provided for node type, or current label length is
                    // less than or equal to the provided length limit.
                    if (maxLength === null || computedTxtLength <= maxLength) {
                        return;
                    }
                    // Find the index of the character which exceeds the width.
                    // getSubStringLength performs far better than getComputedTextLength, and
                    // results in a 3x speed-up on average.
                    var index = 1;
                    while (txtNode.getSubStringLength(0, index) < maxLength) {
                        index++;
                    }
                    // Shorten the label starting at the string length known to be one
                    // character above max pixel length.
                    // When shortened the original label's substring is concatenated with
                    // '...', baseText contains the substring not including the '...'.
                    var baseText = txtNode.textContent.substr(0, index);
                    do {
                        baseText = baseText.substr(0, baseText.length - 1);
                        // Recompute text length.
                        txtNode.textContent = baseText + '...';
                        computedTxtLength = txtNode.getComputedTextLength();
                    } while (computedTxtLength > maxLength && baseText.length > 0);
                    // Add tooltip with full name and return.
                    return txtElementSelection.append('title').text(labelContent);
                }
                node_1.enforceLabelWidth = enforceLabelWidth;
                /**
                 * d3 scale used for sizing font of labels, used by labelBuild,
                 * initialized once by getLabelFontScale.
                 */
                var fontScale = null;
                function getLabelFontScale(sceneElement) {
                    if (!fontScale) {
                        fontScale = d3.scaleLinear()
                            .domain([sceneElement.maxMetanodeLabelLengthLargeFont,
                            sceneElement.maxMetanodeLabelLength])
                            .range([sceneElement.maxMetanodeLabelLengthFontSize,
                            sceneElement.minMetanodeLabelLengthFontSize]).clamp(true);
                    }
                    return fontScale;
                }
                /**
                 * Set label position of a given node group
                 */
                function labelPosition(nodeGroup, cx, cy, yOffset) {
                    scene.selectChild(nodeGroup, 'text', scene.Class.Node.LABEL)
                        .transition()
                        .attr('x', cx)
                        .attr('y', cy + yOffset);
                }
                ;
                /**
                 * Select or append/insert shape for a node and assign renderNode
                 * as the shape's data.
                 *
                 * @param nodeGroup
                 * @param d Render node information.
                 * @param nodeClass class for the element.
                 * @return Selection of the shape.
                 */
                function buildShape(nodeGroup, d, nodeClass) {
                    // Create a group to house the underlying visual elements.
                    var shapeGroup = scene.selectOrCreateChild(nodeGroup, 'g', nodeClass);
                    // TODO: DOM structure should be templated in HTML somewhere, not JS.
                    switch (d.node.type) {
                        case graph.NodeType.OP:
                            var opNode = d.node;
                            if (_.isNumber(opNode.functionInputIndex) ||
                                _.isNumber(opNode.functionOutputIndex)) {
                                // This is input or output arg for a TensorFlow function. Use a special
                                // shape (a triangle) for them.
                                scene.selectOrCreateChild(shapeGroup, 'polygon', scene.Class.Node.COLOR_TARGET);
                                break;
                            }
                            scene.selectOrCreateChild(shapeGroup, 'ellipse', scene.Class.Node.COLOR_TARGET);
                            break;
                        case graph.NodeType.SERIES:
                            // Choose the correct stamp to use to represent this series.
                            var stampType = 'annotation';
                            var groupNodeInfo = d;
                            if (groupNodeInfo.coreGraph) {
                                stampType =
                                    groupNodeInfo.node.hasNonControlEdges ? 'vertical' : 'horizontal';
                            }
                            var classList = [scene.Class.Node.COLOR_TARGET];
                            if (groupNodeInfo.isFadedOut) {
                                classList.push('faded-ellipse');
                            }
                            scene.selectOrCreateChild(shapeGroup, 'use', classList)
                                .attr('xlink:href', '#op-series-' + stampType + '-stamp');
                            scene.selectOrCreateChild(shapeGroup, 'rect', scene.Class.Node.COLOR_TARGET)
                                .attr('rx', d.radius).attr('ry', d.radius);
                            break;
                        case graph.NodeType.BRIDGE:
                            scene.selectOrCreateChild(shapeGroup, 'rect', scene.Class.Node.COLOR_TARGET)
                                .attr('rx', d.radius).attr('ry', d.radius);
                            break;
                        case graph.NodeType.META:
                            scene.selectOrCreateChild(shapeGroup, 'rect', scene.Class.Node.COLOR_TARGET)
                                .attr('rx', d.radius).attr('ry', d.radius);
                            break;
                        default:
                            throw Error('Unrecognized node type: ' + d.node.type);
                    }
                    return shapeGroup;
                }
                node_1.buildShape = buildShape;
                ;
                function nodeClass(d) {
                    switch (d.node.type) {
                        case graph.NodeType.OP:
                            return scene.Class.OPNODE;
                        case graph.NodeType.META:
                            return scene.Class.METANODE;
                        case graph.NodeType.SERIES:
                            return scene.Class.SERIESNODE;
                        case graph.NodeType.BRIDGE:
                            return scene.Class.BRIDGENODE;
                        case graph.NodeType.ELLIPSIS:
                            return scene.Class.ELLIPSISNODE;
                    }
                    ;
                    throw Error('Unrecognized node type: ' + d.node.type);
                }
                node_1.nodeClass = nodeClass;
                ;
                /** Modify node and its subscene and its label's positional attributes */
                function position(nodeGroup, d) {
                    var shapeGroup = scene.selectChild(nodeGroup, 'g', scene.Class.Node.SHAPE);
                    var cx = graph.layout.computeCXPositionOfNodeShape(d);
                    switch (d.node.type) {
                        case graph.NodeType.OP: {
                            // position shape
                            var opNode = d.node;
                            if (_.isNumber(opNode.functionInputIndex) ||
                                _.isNumber(opNode.functionOutputIndex)) {
                                // This shape represents the input into or output out of a TensorFlow
                                // function.
                                var shape = scene.selectChild(shapeGroup, 'polygon');
                                scene.positionTriangle(shape, d.x, d.y, d.coreBox.width, d.coreBox.height);
                            }
                            else {
                                var shape = scene.selectChild(shapeGroup, 'ellipse');
                                scene.positionEllipse(shape, cx, d.y, d.coreBox.width, d.coreBox.height);
                            }
                            labelPosition(nodeGroup, cx, d.y, d.labelOffset);
                            break;
                        }
                        case graph.NodeType.META: {
                            // position shape
                            var shapes = shapeGroup.selectAll('rect');
                            if (d.expanded) {
                                scene.positionRect(shapes, d.x, d.y, d.width, d.height);
                                subscenePosition(nodeGroup, d);
                                // Put the label on top.
                                labelPosition(nodeGroup, cx, d.y, -d.height / 2 + d.labelHeight / 2);
                            }
                            else {
                                scene.positionRect(shapes, cx, d.y, d.coreBox.width, d.coreBox.height);
                                // Place the label in the middle.
                                labelPosition(nodeGroup, cx, d.y, 0);
                            }
                            break;
                        }
                        case graph.NodeType.SERIES: {
                            var shape = scene.selectChild(shapeGroup, 'use');
                            if (d.expanded) {
                                scene.positionRect(shape, d.x, d.y, d.width, d.height);
                                subscenePosition(nodeGroup, d);
                                // put label on top
                                labelPosition(nodeGroup, cx, d.y, -d.height / 2 + d.labelHeight / 2);
                            }
                            else {
                                scene.positionRect(shape, cx, d.y, d.coreBox.width, d.coreBox.height);
                                labelPosition(nodeGroup, cx, d.y, d.labelOffset);
                            }
                            break;
                        }
                        case graph.NodeType.BRIDGE: {
                            // position shape
                            // NOTE: In reality, these will not be visible, but it helps to put them
                            // in the correct position for debugging purposes.
                            var shape = scene.selectChild(shapeGroup, 'rect');
                            scene.positionRect(shape, d.x, d.y, d.width, d.height);
                            break;
                        }
                        default: {
                            throw Error('Unrecognized node type: ' + d.node.type);
                        }
                    }
                }
                ;
                /** Enum specifying the options to color nodes by */
                var ColorBy;
                (function (ColorBy) {
                    ColorBy[ColorBy["STRUCTURE"] = 0] = "STRUCTURE";
                    ColorBy[ColorBy["DEVICE"] = 1] = "DEVICE";
                    ColorBy[ColorBy["XLA_CLUSTER"] = 2] = "XLA_CLUSTER";
                    ColorBy[ColorBy["COMPUTE_TIME"] = 3] = "COMPUTE_TIME";
                    ColorBy[ColorBy["MEMORY"] = 4] = "MEMORY";
                    ColorBy[ColorBy["OP_COMPATIBILITY"] = 5] = "OP_COMPATIBILITY";
                })(ColorBy = node_1.ColorBy || (node_1.ColorBy = {}));
                ;
                /**
                 * Returns the fill color for the node given its state and the 'color by'
                 * option.
                 */
                function getFillForNode(templateIndex, colorBy, renderInfo, isExpanded) {
                    var colorParams = graph.render.MetanodeColors;
                    switch (colorBy) {
                        case ColorBy.STRUCTURE:
                            if (renderInfo.node.type === graph.NodeType.META) {
                                var tid = renderInfo.node.templateId;
                                return tid === null ?
                                    colorParams.UNKNOWN :
                                    colorParams.STRUCTURE_PALETTE(templateIndex(tid), isExpanded);
                            }
                            else if (renderInfo.node.type === graph.NodeType.SERIES) {
                                // If expanded, we're showing the background rect, which we want to
                                // appear gray. Otherwise we're showing a stack of ellipses which we
                                // want to show white.
                                return isExpanded ? colorParams.EXPANDED_COLOR : 'white';
                            }
                            else if (renderInfo.node.type === graph.NodeType.BRIDGE) {
                                return renderInfo.structural ?
                                    '#f0e' :
                                    renderInfo.node.inbound ? '#0ef' : '#fe0';
                            }
                            else if (_.isNumber(renderInfo.node.functionInputIndex)) {
                                // This is an input of a TensorFlow function.
                                return '#795548';
                            }
                            else if (_.isNumber(renderInfo.node.functionOutputIndex)) {
                                // This is an output of a TensorFlow function.
                                return '#009688';
                            }
                            else {
                                // Op nodes are white.
                                return 'white';
                            }
                        case ColorBy.DEVICE:
                            if (renderInfo.deviceColors == null) {
                                // Return the hue for unknown device.
                                return colorParams.UNKNOWN;
                            }
                            var id = renderInfo.node.name;
                            var escapedId = tf.graph.util.escapeQuerySelector(id);
                            var gradientDefs = d3.select('svg#svg defs #linearGradients');
                            var linearGradient_1 = gradientDefs.select('linearGradient#' + escapedId);
                            // If the linear gradient is not there yet, create it.
                            if (linearGradient_1.size() === 0) {
                                linearGradient_1 = gradientDefs.append('linearGradient').attr('id', id);
                                // Re-create the stops of the linear gradient.
                                linearGradient_1.selectAll('*').remove();
                                var cumulativeProportion_1 = 0;
                                // For each device, create a stop using the proportion of that device.
                                _.each(renderInfo.deviceColors, function (d) {
                                    var color = d.color;
                                    linearGradient_1.append('stop')
                                        .attr('offset', cumulativeProportion_1)
                                        .attr('stop-color', color);
                                    linearGradient_1.append('stop')
                                        .attr('offset', cumulativeProportion_1 + d.proportion)
                                        .attr('stop-color', color);
                                    cumulativeProportion_1 += d.proportion;
                                });
                            }
                            return isExpanded ? colorParams.EXPANDED_COLOR : "url(#" + escapedId + ")";
                        case ColorBy.XLA_CLUSTER:
                            return isExpanded ? colorParams.EXPANDED_COLOR :
                                renderInfo.xlaClusterColor || colorParams.UNKNOWN;
                        case ColorBy.COMPUTE_TIME:
                            return isExpanded ?
                                colorParams.EXPANDED_COLOR : renderInfo.computeTimeColor ||
                                colorParams.UNKNOWN;
                        case ColorBy.MEMORY:
                            return isExpanded ?
                                colorParams.EXPANDED_COLOR : renderInfo.memoryColor ||
                                colorParams.UNKNOWN;
                        case ColorBy.OP_COMPATIBILITY:
                            if (renderInfo.node.type === graph.NodeType.OP) {
                                return (renderInfo.node.compatible) ?
                                    tf.graph.render.OpNodeColors.COMPATIBLE :
                                    tf.graph.render.OpNodeColors.INCOMPATIBLE;
                            }
                            else if (renderInfo.node.isGroupNode) {
                                var node_2 = renderInfo.node;
                                var numCompat = node_2.compatibilityHistogram.compatible;
                                var numIncompat = node_2.compatibilityHistogram.incompatible;
                                if (numCompat == 0 && numIncompat == 0) {
                                    // Return the hue for unknown device.
                                    return colorParams.UNKNOWN;
                                }
                                var id_1 = "op-compat-" + node_2.name;
                                var escapedId_1 = tf.graph.util.escapeQuerySelector(id_1);
                                var gradientDefs_1 = d3.select('svg#svg defs #linearGradients');
                                var linearGradient_2 = gradientDefs_1.select('linearGradient#' + escapedId_1);
                                // If the linear gradient is not there yet, create it.
                                if (linearGradient_2.size() === 0) {
                                    var percentValid = numCompat / (numCompat + numIncompat);
                                    linearGradient_2 = gradientDefs_1.append('linearGradient').attr('id', id_1);
                                    // Re-create the stops of the linear gradient.
                                    linearGradient_2.selectAll('*').remove();
                                    linearGradient_2.append('stop')
                                        .attr('offset', 0)
                                        .attr('stop-color', tf.graph.render.OpNodeColors.COMPATIBLE);
                                    linearGradient_2.append('stop')
                                        .attr('offset', percentValid)
                                        .attr('stop-color', tf.graph.render.OpNodeColors.COMPATIBLE);
                                    linearGradient_2.append('stop')
                                        .attr('offset', percentValid)
                                        .attr('stop-color', tf.graph.render.OpNodeColors.INCOMPATIBLE);
                                    linearGradient_2.append('stop')
                                        .attr('offset', 1)
                                        .attr('stop-color', tf.graph.render.OpNodeColors.INCOMPATIBLE);
                                }
                                return isExpanded ? colorParams.EXPANDED_COLOR : "url(#" + escapedId_1 + ")";
                            }
                            else {
                                // All other nodes will be set to the default color
                                return colorParams.DEFAULT_FILL;
                            }
                        default:
                            throw new Error('Unknown case to color nodes by');
                    }
                }
                node_1.getFillForNode = getFillForNode;
                /**
                 * Modify node style by toggling class and assign attributes (only for things
                 * that can't be done in css).
                 */
                function stylize(nodeGroup, renderInfo, sceneElement, nodeClass) {
                    nodeClass = nodeClass || scene.Class.Node.SHAPE;
                    var isHighlighted = sceneElement.isNodeHighlighted(renderInfo.node.name);
                    var isSelected = sceneElement.isNodeSelected(renderInfo.node.name);
                    var isExtract = renderInfo.isInExtract ||
                        renderInfo.isOutExtract ||
                        renderInfo.isLibraryFunction;
                    var isExpanded = renderInfo.expanded && nodeClass !== scene.Class.Annotation.NODE;
                    var isFadedOut = renderInfo.isFadedOut;
                    nodeGroup.classed('highlighted', isHighlighted);
                    nodeGroup.classed('selected', isSelected);
                    nodeGroup.classed('extract', isExtract);
                    nodeGroup.classed('expanded', isExpanded);
                    nodeGroup.classed('faded', isFadedOut);
                    // Main node always exists here and it will be reached before subscene,
                    // so d3 selection is fine here.
                    var node = nodeGroup.select('.' + nodeClass + ' .' + scene.Class.Node.COLOR_TARGET);
                    var fillColor = getFillForNode(sceneElement.templateIndex, ColorBy[sceneElement.colorBy.toUpperCase()], renderInfo, isExpanded);
                    node.style('fill', fillColor);
                    // Choose outline to be darker version of node color if the node is a single
                    // color and is not selected.
                    node.style('stroke', isSelected ? null : getStrokeForFill(fillColor));
                }
                node_1.stylize = stylize;
                ;
                /**
                 * Given a node's fill color/gradient, determine the stroke for the node.
                 */
                function getStrokeForFill(fill) {
                    // If node is colored by a gradient, then use a dark gray outline.
                    return fill.substring(0, 3) === 'url' ?
                        graph.render.MetanodeColors.GRADIENT_OUTLINE :
                        d3.rgb(fill).darker().toString();
                }
                node_1.getStrokeForFill = getStrokeForFill;
                /**
                 * Finds selected node and highlights all nodes which are providing direct
                 * or indirect input to the node and all edges connecting these nodes
                 * together and to the selected node.
                 *
                 * @param renderGraphInfo Information on the rendered state of the graph.
                 */
                function traceInputs(renderGraphInfo) {
                    // Reset all styling.
                    d3.selectAll('.input-highlight').classed('input-highlight', false);
                    d3.selectAll('.non-input').classed('non-input', false);
                    d3.selectAll('.input-parent').classed('input-parent', false);
                    d3.selectAll('.input-child').classed('input-child', false);
                    d3.selectAll('.input-edge-highlight').classed('input-edge-highlight', false);
                    d3.selectAll('.non-input-edge-highlight')
                        .classed('non-input-edge-highlight', false);
                    d3.selectAll('.input-highlight-selected')
                        .classed('input-highlight-selected', false);
                    // Extract currently selected node. Return if input tracing disabled or no
                    // node is selected.
                    var selectedNodeSelectorString = 'g.node.selected,g.op.selected';
                    var nodeSelection = d3.select(selectedNodeSelectorString);
                    var currentNode = undefined;
                    if (renderGraphInfo && renderGraphInfo.traceInputs &&
                        nodeSelection.nodes().length) {
                        currentNode = nodeSelection.nodes()[0];
                    }
                    else {
                        return;
                    }
                    var nodeName = currentNode.getAttribute('data-name');
                    var opNodes = _getAllContainedOpNodes(nodeName, renderGraphInfo);
                    var allTracedNodes = {};
                    _.each(opNodes, function (nodeInstance) {
                        allTracedNodes =
                            traceAllInputsOfOpNode(renderGraphInfo, nodeInstance, allTracedNodes);
                    });
                    d3.selectAll(selectedNodeSelectorString)
                        .classed('input-highlight', false)
                        .classed('input-highlight-selected', true);
                    // Highlight all parent nodes of each OpNode as input parent to allow
                    // specific highlighting.
                    var highlightedNodes = Object.keys(allTracedNodes);
                    var visibleNodes = _findVisibleParentsFromOpNodes(renderGraphInfo, highlightedNodes);
                    _markParentsOfNodes(visibleNodes);
                    // Attach class to all non-input nodes and edges for styling.
                    d3.selectAll('g.node:not(.selected):not(.input-highlight)' +
                        ':not(.input-parent):not(.input-children)')
                        .classed('non-input', true)
                        .each(function (d) {
                        // Mark all nodes with the specified name as non-inputs. This
                        // results in Annotation nodes which are attached to inputs to be
                        // tagged as well.
                        var nodeName = d.node.name;
                        d3.selectAll("[data-name=\"" + nodeName + "\"]").classed('non-input', true);
                    });
                    d3.selectAll('g.edge:not(.input-edge-highlight)')
                        .classed('non-input-edge-highlight', true);
                }
                node_1.traceInputs = traceInputs;
                /**
                 * Recursively find all op nodes contained by the node identified by the
                 * provided name.
                 * @param nodeName The meta or op node of which the OpNode instances are
                 * required.
                 * @param renderGraphInfo The rendered graph information object.
                 * @returns {Array} An array of OpNodeImpl instances.
                 */
                function _getAllContainedOpNodes(nodeName, renderGraphInfo) {
                    var opNodes = [];
                    // Get current node.
                    var node = renderGraphInfo.getNodeByName(nodeName);
                    // If node is already OpNode then return the node plus its input embeddings.
                    if (node instanceof tf.graph.OpNodeImpl) {
                        return [node].concat(node.inEmbeddings);
                    }
                    // Otherwise, make recursive call for each node contained by the GroupNode.
                    var childNodeNames = node.metagraph.nodes();
                    _.each(childNodeNames, function (childNodeName) {
                        opNodes =
                            opNodes.concat(_getAllContainedOpNodes(childNodeName, renderGraphInfo));
                    });
                    return opNodes;
                }
                node_1._getAllContainedOpNodes = _getAllContainedOpNodes;
                function traceAllInputsOfOpNode(renderGraphInfo, startNode, allTracedNodes) {
                    // To prevent infinite loops due to cyclical relationships and improving
                    // performance by tracing OpNode which is input to 2+ nodes only once.
                    if (allTracedNodes[startNode.name]) {
                        return allTracedNodes;
                    }
                    else {
                        allTracedNodes[startNode.name] = true;
                    }
                    // Extract the inputs.
                    var inputs = startNode.inputs;
                    // Get visible parent.
                    var currentVisibleParent = getVisibleParent(renderGraphInfo, startNode);
                    // Mark as input node.
                    d3.select(".node[data-name=\"" + currentVisibleParent.name + "\"]")
                        .classed('input-highlight', true);
                    // Find the visible parent of each input.
                    var visibleInputs = {};
                    _.each(inputs, function (nodeInstance) {
                        var resolvedNode = renderGraphInfo.getNodeByName(nodeInstance.name);
                        if (resolvedNode === undefined) {
                            // Node could not be found in rendered Hierarchy, which happens when
                            // tracing inputs of a SummaryNode.
                            return;
                        }
                        // Ensure node is resolved to OpNode if name collision with Metanode exists.
                        if (resolvedNode instanceof graph.MetanodeImpl) {
                            var resolvedNodeName = tf.graph.getStrictName(resolvedNode.name);
                            resolvedNode = renderGraphInfo.getNodeByName(resolvedNodeName);
                        }
                        var visibleParent = getVisibleParent(renderGraphInfo, resolvedNode);
                        // Append OpNode to visible parent entry.
                        var visibleInputsEntry = visibleInputs[visibleParent.name];
                        if (visibleInputsEntry) {
                            visibleInputsEntry.opNodes.push(resolvedNode);
                        }
                        else {
                            visibleInputs[visibleParent.name] = {
                                visibleParent: visibleParent,
                                opNodes: [resolvedNode]
                            };
                        }
                    });
                    // Find all parents of the start node.
                    var startNodeParents = {};
                    var indexedStartNodeParents = [currentVisibleParent];
                    startNodeParents[currentVisibleParent.name] = {
                        traced: false,
                        index: 0,
                        connectionEndpoints: []
                    };
                    var currentNode = currentVisibleParent;
                    for (var index = 1; currentNode.name !== tf.graph.ROOT_NAME; index++) {
                        currentNode = currentNode.parentNode;
                        startNodeParents[currentNode.name] = {
                            traced: false,
                            index: index,
                            connectionEndpoints: []
                        };
                        indexedStartNodeParents[index] = currentNode;
                    }
                    // Find first mutual parent of each input node and highlight connection.
                    _.forOwn(visibleInputs, function (visibleParentInfo, key) {
                        var nodeInstance = visibleParentInfo.visibleParent;
                        // Make recursive call for each input-OpNode contained by the visible
                        // parent.
                        _.each(visibleParentInfo.opNodes, function (opNode) {
                            allTracedNodes =
                                traceAllInputsOfOpNode(renderGraphInfo, opNode, allTracedNodes);
                        });
                        if (nodeInstance.name !== currentVisibleParent.name) {
                            _createVisibleTrace(nodeInstance, startNodeParents, indexedStartNodeParents);
                        }
                    });
                    return allTracedNodes;
                }
                node_1.traceAllInputsOfOpNode = traceAllInputsOfOpNode;
                /**
                 * Colors the edges to connect the passed node to the start node. This is
                 * done by:
                 *
                 * a) Finding the first (visible) common parent in the rendered
                 * hierarchy.
                 * NB: There are 2 types of connections:
                 * 1) Direct connections between node A
                 * and B, marked below as II,
                 * 2) Connections from any node A to its parent, A'. Marked below as I and III.
                 * For type 2 connection you need to know the inner-nested node, the
                 * direct parent, and the ultimate destination of the connection.
                 *
                 *  A_parent      B_parent
                 * +--------+    +---------+
                 * |        |    |         |
                 * |  +--+ I| II |III+--+  |
                 * |  |A +---------->+B |  |
                 * |  +--+  |    |   +--+  |
                 * |        |    |         |
                 * +--------+    +---------+
                 *
                 *
                 * b) Highlighting the direct connection between the parents of A and B,
                 * called A_parent and B_parent, s.t. A_parent and B_parent are children of the
                 * mutual parent of A and B found in a), marked above as II.
                 *
                 * c) Highlighting the connection from A to A_parent and B to B_parent
                 * (through all layers of parents between A and A_parent and B and B_parent,
                 * respectively). Marked above as I and III.
                 *
                 * @param nodeInstance The instance of the node to use as destination node, B.
                 * @param startNodeParents Map of startNodeParent names to information objects
                 * about the parent.
                 * @param indexedStartNodeParents An array of all parents of the start node.
                 * This is required to find the child of the mutual parent which is a parent
                 * of the start node.
                 * @private
                 */
                function _createVisibleTrace(nodeInstance, startNodeParents, indexedStartNodeParents) {
                    var currentNode = nodeInstance;
                    var previousNode = nodeInstance;
                    // Ascend through parents until a mutual parent is found with the start
                    // node.
                    var destinationParentPairs = [];
                    while (!startNodeParents[currentNode.name]) {
                        if (previousNode.name !== currentNode.name) {
                            destinationParentPairs.push([previousNode, currentNode]);
                        }
                        previousNode = currentNode;
                        currentNode = currentNode.parentNode;
                    }
                    // Connection between nodes is drawn between the parents of each
                    // respective node, both of which share the mutual parent.
                    var startNodeIndex = startNodeParents[currentNode.name].index;
                    var startNodeName = indexedStartNodeParents[Math.max(startNodeIndex - 1, 0)].name;
                    var startNodeTopParentName = startNodeName;
                    var targetNodeTopParentName = previousNode.name;
                    var endNodeName = previousNode.name;
                    d3.selectAll("[data-edge=\"" + endNodeName + "--" + startNodeName + "\"]")
                        .classed('input-edge-highlight', true);
                    // Trace up the parents of the input.
                    _.each(destinationParentPairs, function (value) {
                        var inner = value[0];
                        var outer = value[1];
                        var edgeSelector = "[data-edge=\"" + inner.name + "--" + startNodeTopParentName +
                            ("~~" + outer.name + "~~OUT\"]");
                        d3.selectAll(edgeSelector).classed('input-edge-highlight', true);
                    });
                    // Trace up the parents of the start node.
                    for (var index = 1; index < startNodeIndex; index++) {
                        var inner = indexedStartNodeParents[index - 1];
                        var outer = indexedStartNodeParents[index];
                        var edgeSelector = "[data-edge=\"" + targetNodeTopParentName + "~~" + outer.name +
                            ("~~IN--" + inner.name + "\"]");
                        d3.selectAll(edgeSelector).classed('input-edge-highlight', true);
                    }
                }
                /**
                 * Creates map { [name: string] -> Node } of all visible / rendered parents
                 * of the nodes identified by the node names passed in.
                 *
                 * @param renderGraphInfo The information on the rendered graph.
                 * @param nodeNames String array of node names.
                 * @returns {[nodeName: string]: Node}
                 * @private
                 */
                function _findVisibleParentsFromOpNodes(renderGraphInfo, nodeNames) {
                    var visibleParents = {};
                    _.each(nodeNames, function (nodeName) {
                        var currentNode = renderGraphInfo.getNodeByName(nodeName);
                        var visibleParent = getVisibleParent(renderGraphInfo, currentNode);
                        visibleParents[visibleParent.name] = visibleParent;
                    });
                    return visibleParents;
                }
                /**
                 * Traverse through the parents of all nodes in the list and mark each
                 * encountered node as input-parent.
                 * @param visibleNodes Map of input nodes, have to be visible/rendered when
                 * called.
                 * @private
                 */
                function _markParentsOfNodes(visibleNodes) {
                    _.forOwn(visibleNodes, function (nodeInstance) {
                        // Mark all parents of the node as input-parents.
                        var currentNode = nodeInstance;
                        while (currentNode.name !== tf.graph.ROOT_NAME) {
                            var renderedElementSelection = d3.select(".node[data-name=\"" + currentNode.name + "\"]");
                            // Only mark the element as a parent node to an input if it is not
                            // marked as input node itself.
                            if (renderedElementSelection.nodes().length &&
                                !renderedElementSelection.classed('input-highlight') &&
                                !renderedElementSelection.classed('selected') &&
                                // OpNode only parent if start node is embedded node, in which case
                                // the OpNode should be faded as well.
                                !renderedElementSelection.classed('op')) {
                                renderedElementSelection.classed('input-parent', true);
                            }
                            currentNode = currentNode.parentNode;
                        }
                    });
                }
                /**
                 * Find the parent of the passed in op node which is expanded. This is done
                 * by going through all parents until the parent's parent is expanded, thus
                 * finding the first unexpanded parent which is rendered on the screen.
                 * @param renderGraphInfo The graph info object used to gain access to the
                 * render info of the parents.
                 * @param currentNode The node whose parent is to be found.
                 * @returns Node
                 */
                function getVisibleParent(renderGraphInfo, currentNode) {
                    var found = false;
                    var currentParent = currentNode;
                    while (!found) {
                        // Get parent element, to extract name.
                        currentNode = currentParent;
                        currentParent = currentNode.parentNode;
                        if (currentParent === undefined) {
                            found = true;
                        }
                        else {
                            var renderNode = renderGraphInfo.getRenderNodeByName(currentParent.name);
                            // Found if node is rendered on the screen (renderNode truthy), and
                            // the parent is either expanded (i.e. it is a metanode or seriesnode)
                            // or the parent is an OpNode in which case currentNode is an embedded
                            // node which has another OpNode as parent.
                            if (renderNode &&
                                (renderNode.expanded || currentParent instanceof graph.OpNodeImpl)) {
                                found = true;
                            }
                        }
                    } // Close while loop.
                    return currentNode;
                }
                node_1.getVisibleParent = getVisibleParent;
            })(node = scene.node || (scene.node = {}));
        })(scene = graph.scene || (graph.scene = {}));
    })(graph = tf.graph || (tf.graph = {}));
})(tf || (tf = {})); // Close module.
