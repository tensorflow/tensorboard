<!--
@license
Copyright 2018 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<link rel="import" href="../iron-icons/av-icons.html" />
<link rel="import" href="../iron-icons/communication-icons.html" />
<link rel="import" href="../iron-collapse/iron-collapse.html" />
<link rel="import" href="../iron-icons/editor-icons.html" />
<link rel="import" href="../iron-icons/hardware-icons.html" />
<link rel="import" href="../iron-icons/iron-icons.html" />
<link rel="import" href="../iron-pages/iron-pages.html" />
<link rel="import" href="../paper-button/paper-button.html" />
<link rel="import" href="../paper-dialog/paper-dialog.html" />
<link rel="import" href="../paper-toggle-button/paper-toggle-button.html" />
<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu.html" />
<link rel="import" href="../paper-icon-button/paper-icon-button.html" />
<link rel="import" href="../paper-input/paper-input.html" />
<link rel="import" href="../paper-item/paper-item.html" />
<link rel="import" href="../paper-listbox/paper-listbox.html" />
<link rel="import" href="../paper-radio-button/paper-radio-button.html" />
<link rel="import" href="../paper-radio-group/paper-radio-group.html" />
<link rel="import" href="../paper-slider/paper-slider.html" />
<link rel="import" href="../paper-spinner/paper-spinner-lite.html" />
<link rel="import" href="../paper-tabs/paper-tab.html" />
<link rel="import" href="../paper-tabs/paper-tabs.html" />
<link rel="import" href="../paper-toast/paper-toast.html" />
<link rel="import" href="../tf-backend/tf-backend.html" />
<link rel="import" href="../tf-dashboard-common/dashboard-style.html" />
<link rel="import" href="../tf-dashboard-common/tf-dashboard-layout.html" />
<link rel="import" href="../tf-dashboard-common/tf-option-selector.html" />
<link rel="import" href="../tf-imports/polymer.html" />
<link rel="import" href="../tf-storage/tf-storage.html" />
<link rel="import" href="./tf-inference-panel.html" />
<link rel="import" href="../tf-tensorboard/plugin-dialog.html" />
<link rel="import" href="../tf-tensorboard/registry.html" />
<link rel="import" href="../vz-bar-chart/vz-bar-chart.html" />
<link rel="import" href="../vz-line-chart2/vz-line-chart2.html" />
<link rel="import" href="./tf-confusion-matrix.html" />
<link rel="import" href="./tf-inference-viewer.html" />
<link
  rel="import"
  href="../facets-dive/components/facets-dive/facets-dive.html"
/>
<link
  rel="import"
  href="../facets-overview/components/facets-overview/facets-overview.html"
/>
<link rel="import" href="../vz-example-viewer/vz-example-viewer.html" />
<!--
  A frontend that displays a set of editable examples and enables inference of those examples,
  visualizing the results.
-->
<dom-module id="tf-interactive-inference-dashboard">
  <template>
    <style id="linter-paper-button-style">
      /**
       * This style preserves the styling previous to
       * https://github.com/PolymerElements/paper-button/pull/115
       * This change can break the layout of paper-button content.
       * Remove this style to apply the change, more details at b/70528356.
       */
      paper-button {
        display: inline-block;
        text-align: center;
        font-family: inherit;
      }
    </style>
    <style>
      :host {
        font-family: 'Roboto', 'Noto', sans-serif;
        --paper-tab-ink: var(--tb-orange-dark);
        --wit-color-gray300: #dadce0;
      }

      [hidden] {
        display: none !important;
      }

      #classification {
        width: 40%;
      }

      .example-holder {
        width: 100%;
      }

      .inference-section-holder {
        display: flex;
        margin-top: 6px;
        margin-right: 6px;
      }

      .inference-section {
        width: 100%;
        border: 1px solid var(--wit-color-gray300);
      }

      .inference-viewer {
        max-height: 35%;
        flex-grow: 1;
      }

      .compare-inference-viewer {
        border-left: 1px solid var(--wit-color-gray300);
      }

      .tf-option-selector-0 .content-wrapper.tf-option-selector > * {
        width: 40%;
      }

      #spinner {
        position: absolute;
        top: 95px;
        left: 10px;
        width: 14px;
        height: 14px;
        --paper-spinner-color: var(--tb-orange-strong);
      }

      .noexamples {
        position: absolute;
        top: 75px;
        left: 30px;
      }

      .center {
        position: relative;
      }

      .info-text {
        font-size: 14px;
        color: #3c4043;
        letter-spacing: 0.25px;
        line-height: 20px;
        margin: 12px auto;
      }

      .pd-info-text {
        font-size: 18px;
        color: #3c4043;
        line-height: 24px;
        padding-top: 12px;
        padding-right: 4px;
        padding-left: 12px;
      }

      .pd-no-features-text {
        font-size: 18px;
        color: #3c4043;
        padding: 12px 48px;
      }

      .accept-button-holder {
        display: flex;
        flex-direction: row-reverse;
      }

      .settings-button {
        margin-top: 4px;
      }

      .datapoint-right-controls-holder .control {
        flex-shrink: 0;
      }

      .button {
        font-size: 13px;
        margin: 10px 0 0 0;
        background-color: var(--tb-orange-strong);
        color: white;
      }

      .button[disabled] {
        background-color: #ccc;
      }

      .input-and-tooltip {
        display: flex;
      }

      .label-vocab-path-input {
        flex-grow: 1;
      }

      .threshold-dropdown {
        display: block;
        width: 150px;
        min-width: 150px;
        padding-right: 16px;
        --paper-input-container-input: {
          font-size: 14px;
          color: #3c4043;
        }
      }

      .short-dropdown {
        display: inline-block;
        width: 100px;
        min-width: 50px;
        padding-right: 5px;
        --paper-input-container-input: {
          font-size: 14px;
          color: #3c4043;
        }
      }

      .slider-label {
        margin-top: 8px;
      }

      .facet-label {
        --paper-input-container-underline: {
          display: none;
        }
        --paper-input-container-input: {
          font-weight: 500;
        }
      }

      .slider {
        width: 280px;
        --paper-slider-input: {
          width: 80px;
        }
      }

      .slider-model-one {
        --paper-slider-knob-color: #12b5ce;
        --paper-slider-active-color: #12b5ce;
      }

      .slider-model-two {
        --paper-slider-knob-color: #fa7817;
        --paper-slider-active-color: #fa7817;
      }

      paper-dialog.inference-settings {
        padding: 20px;
        width: 40%;
        max-width: 40%;
        overflow-y: auto;
        border-radius: 10px;
      }

      .dashboard-layout {
        display: flex;
        height: 100%;
        background-color: white;
      }

      .center {
        width: 60%;
      }

      .side-holder {
        position: relative;
        width: 40%;
        display: flex;
      }

      .side-content {
        padding-left: 5px;
        width: calc(100% - 10px);
        display: flex;
        flex-direction: column;
      }

      .side-tabs {
        display: flex;
        height: calc(100% - 50px);
      }

      .datapoint-tab {
        display: flex;
        width: 100%;
        overflow: auto;
      }

      .config-tab {
        width: 100%;
        display: flex;
      }

      .config-side-content {
        padding-left: 5px;
        width: 30%;
        overflow-y: auto;
        border-right: 1px solid var(--wit-color-gray300);
      }

      .config-main-content {
        width: 70%;
        display: flex;
        flex-direction: column;
        background: #f8f9fa;
      }

      .stats-tab {
        width: 100%;
        display: flex;
        overflow: auto;
      }

      .pd-tab {
        width: 100%;
        padding: 5px 10px;
      }

      .pd-plots-header {
        height: 52px;
        min-height: 52px;
        max-height: 52px;
        border-bottom: solid 2px var(--wit-color-gray300);
        display: flex;
        justify-content: space-between;
      }

      .pdplots-holder {
        flex-grow: 1;
        overflow-y: overlay;
        background: #f8f9fa;
      }

      .pd-range-hyphen {
        padding-right: 6px;
        padding-top: 8px;
      }

      .pd-range-control {
        border-bottom: solid 1px #fcc934;
        border-top: none;
        border-left: none;
        border-right: none;
        height: 36px;
        width: 104px;
        margin-right: 6px;
      }

      #overview {
        max-height: 100%;
        height: 100%;
      }

      .inference-header.heading {
        background: #e4f7fb;
      }

      .right-side {
        position: absolute;
        right: 0;
        top: 0;
      }

      .right-side-performance-tab {
        margin: 4px;
      }

      tf-confusion-matrix {
        display: block;
      }

      .datapoint-controls-holder.datapoint-control-buttons-holder {
        padding-left: 2px;
      }

      .datapoint-controls-holder.datapoint-control-search-holder {
        padding-left: 10px;
      }

      .datapoint-controls-holder {
        border-bottom: 1px solid var(--wit-color-gray300);
        display: flex;
        flex-grow: 0;
        flex-shrink: 0;
        justify-content: space-between;
        margin-left: 1px;
      }

      .datapoint-left-controls-holder {
        display: flex;
        flex-wrap: wrap;
      }

      .datapoint-right-controls-holder {
        display: flex;
        flex-direction: row-reverse;
        overflow: hidden;
      }

      .tf-category-pane {
        flex-grow: 1;
      }

      .tf-category-pane-content {
        flex-wrap: wrap;
        flex-grow: 1;
        padding: 12px;
        border: 1px solid var(--wit-color-gray300);
        border-top: none;
        border-bottom-left-radius: 2px;
        border-bottom-right-radius: 2px;
        background: white;
      }

      :host vz-line-chart2 {
        margin: 12px 12px 12px 24px;
        height: 180px;
        width: 300px;
        display: inline-block;
      }

      :host vz-bar-chart {
        margin: 12px 12px 12px 24px;
        height: 240px;
        width: 450px;
        display: inline-block;
      }

      .pd-input-container {
        display: block;
        flex-grow: 0;
        padding: 12px 48px 24px 24px;
        background: #fef7e0;
        border: solid 1px #fde293;
      }

      .style-input {
        width: 50px;
        text-align: right;
        background: white;
      }

      .feature-container-holder {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background: white;
        display: none;
        flex-direction: column;
      }

      .datapoint-control-filter-input {
        border-radius: 2px;
        max-width: 60%;
        --paper-input-container: {
          padding: 4px 6px 2px 4px;
        }
        --paper-input-container-input: {
          font-size: 14px;
          color: #3c4043;
        }
        --paper-input-container-label: {
          font-size: 14px;
          color: #80868b;
        }
      }

      .datapoint-control-filter-input iron-icon {
        color: #9ba0a6;
      }

      .feature-search-input {
        padding-top: 3px;
        flex-grow: 1;
        max-width: 150px;
      }

      .num-buckets-input {
        width: 45px;
        margin-right: 8px;
      }

      .control-button {
        background-color: white;
        border: 1px solid var(--wit-color-gray300);
        color: var(--tb-orange-dark);
        font-size: 14px;
        font-weight: 400;
        padding: 8px 12px;
        text-transform: none;
        margin: 5px;
      }

      .control-button[disabled] {
        color: #5f6368;
        background-color: #f4f4f4;
      }

      .main-button {
        background-color: var(--tb-orange-dark);
        border: 1px solid var(--tb-orange-dark);
        color: white;
        font-size: 14px;
        font-weight: 400;
        padding: 8px 12px;
        text-transform: none;
        margin: 5px;
      }

      .main-button[disabled] {
        background-color: lightgray;
        border: 1px solid lightgray;
        color: gray;
      }

      .optimize-threshold-button {
        margin: 5px 0;
        width: 150px;
        min-width: 150px;
        margin-right: 16px;
      }

      .close-partial-deps-button {
        margin: 10px;
      }

      paper-tabs {
        flex-grow: 1;
        width: 100%;
        height: 100%;
        --paper-tabs-selection-bar-color: var(--tb-orange-dark);
      }

      paper-tab {
        font-size: 14px;
        font-weight: 400;
        padding: 0 24px;
        letter-spacing: 0.1px;
      }

      paper-tab:not(.iron-selected) {
        color: #3c4043;
      }

      paper-tab.iron-selected {
        color: #202124;
        font-weight: 500;
      }

      .perfs-holder {
        display: flex;
        justify-content: center;
        width: 100%;
        flex-wrap: wrap;
        margin: 4px;
        position: relative;
      }

      .perf-holder {
        margin: 8px;
        position: relative;
      }

      .perf-curve-x-label {
        position: absolute;
        bottom: 2px;
        left: 138px;
        font-size: 12px;
        color: #5f6368;
        padding: 0px;
        width: 120px;
        text-align: center;
      }

      .perf-curve-y-label {
        position: absolute;
        left: 44px;
        bottom: 54px;
        transform: rotate(270deg);
        transform-origin: left bottom;
        font-size: 12px;
        color: #5f6368;
        width: 120px;
        text-align: center;
      }

      .flex {
        display: flex;
      }

      .space-between {
        justify-content: space-between;
      }

      .flex-wrap {
        display: flex;
        flex-wrap: wrap;
      }

      .optimize-text {
        margin: 5px 0;
        color: grey;
        font-size: 14px;
      }

      .threshold-cost-input {
        width: 150px;
        min-width: 150px;
        margin-right: 16px;
        --paper-input-container-input: {
          font-size: 14px;
          color: #3c4043;
        }
        --paper-input-container-label: {
          font-size: 14px;
          color: #80868b;
        }
      }

      .bold {
        font-weight: 500;
      }

      .indent {
        margin-left: 10px;
      }

      .feature-breakdown {
        margin-left: 12px;
      }

      .optimize-selection-button {
        margin-left: 0;
        margin-bottom: 5px;
      }

      .reg-table-category {
        text-align: left;
      }

      .reg-table-value {
        text-align: right;
      }

      .subfeature-table {
        margin-left: 10px;
      }

      .counterfactual-button-intro {
        padding: 7px 0 0 10px;
      }

      .main-vertical {
        width: 100%;
      }

      .main-bottom-bar {
        height: 52px;
        min-height: 52px;
        flex-grow: 0;
        display: flex;
        /* box-shadow: 0 2px 5px grey;
        margin-bottom: 3px; */
        border-bottom: solid 1px #dadce0;
        justify-content: space-between;
      }

      .main-content {
        height: 100%;
      }

      .dist-switch {
        display: flex;
        margin-top: 0;
      }

      .distance-vis-dropdown {
        margin-top: 0;
      }

      #distancedialog {
        width: 30%;
      }

      #distancedialog .buttons {
        color: #f57c00;
      }

      paper-radio-button {
        --paper-radio-button-label: {
          font-size: 14px;
          color: #3c4043;
        }
        --paper-radio-button-unchecked-color: #3c4043;
        --paper-radio-button-unchecked-ink-color: #3c4043;
        --paper-radio-button-checked-color: #3c4043;
        --paper-radio-button-checked-ink-color: #3c4043;
      }

      paper-icon-button {
        color: #5f6368;
      }

      paper-icon-button[disabled] {
        color: #9aa0a6;
      }

      .resizer {
        display: table;
        height: 100%;
        width: 8px;
        border-left: 1px solid var(--wit-color-gray300);
        border-right: 1px solid var(--wit-color-gray300);
        cursor: pointer;
      }

      .example-status {
        font-size: 12px;
        color: #5f6368;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        padding-top: 20px;
      }

      .example-id-label {
        padding: 9px 5px 9px 0;
      }

      .example-id-input {
        width: 70px;
        padding-top: 3px;
      }

      .heading-and-card {
        border: 1px solid lightgray;
        margin-right: 5px;
        margin-top: 5px;
        padding-top: 1px;
      }

      .editor-heading-and-card {
        flex: 1;
        overflow-y: overlay;
      }

      .heading {
        color: #5f6368;
        position: relative;
        padding: 10px 8px;
        background-color: #fef7e0;
        border-bottom: 1px solid var(--wit-color-gray300);
        border-top: none;
        border-left: none;
        border-right: none;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        width: 100%;
        text-align: left;
      }

      .card {
        padding: 0 10px 5px;
      }

      .no-padding-card {
        padding: 0;
      }

      .tooltip {
        --paper-tooltip: {
          font-size: 16px;
        }
        --paper-tooltip-delay-out: 2000ms;
      }

      .comment-icon {
        width: 30px;
        height: 30px;
        min-width: 30px;
        min-height: 30px;
        margin-top: 10px;
        color: var(--tb-orange-dark);
      }

      .arrow-icon {
        width: 50px;
        height: 50px;
        min-width: 50px;
        min-height: 50px;
        color: var(--tb-orange-dark);
      }

      .pd-arrow-icon {
        width: 40px;
        height: 40px;
        min-width: 40px;
        min-height: 40px;
        margin-top: 5px;
        color: grey;
      }

      .pd-toggle {
        margin: 0 8px 0 20px;
      }

      .pd-entry-container {
        display: flex;
        flex-direction: row-reverse;
        justify-content: space-between;
        flex-grow: 1;
      }

      .info-icon {
        width: 20px;
        height: 20px;
        min-width: 20px;
        min-height: 20px;
        margin-top: 10px;
        color: grey;
      }

      .info-icon.cf-info-icon {
        margin-top: 12px;
      }

      .info-icon.thresh-info-icon {
        margin-top: -3px;
        vertical-align: middle;
      }

      .info-icon.pd-info-icon {
        margin-top: 15px;
      }

      .info-icon.threshold-info-icon {
        margin-top: 0;
        margin-bottom: 10px;
        margin-left: 5px;
      }

      .info-icon.performance-info-icon {
        margin-top: 18px;
        margin-bottom: 10px;
        margin-left: 5px;
      }

      .no-padding {
        padding: 0;
      }

      .resize-icon {
        display: table-cell;
        vertical-align: middle;
        color: grey;
        width: 10px;
        height: 10px;
        min-width: 10px;
        min-height: 10px;
      }

      .help-text {
        color: #5f6368;
        font-size: 10px;
        max-width: 200px;
      }

      .help-title {
        color: #007b7c;
        font-size: 11px;
        font-weight: 500;
        text-transform: uppercase;
      }

      .help-title-margin {
        margin-top: 14px;
      }

      .help-title-margin-button {
        margin-top: 4px;
      }

      .help-title-margin-title {
        margin-top: 7px;
      }

      .dialog-link {
        color: #5f6368;
        font-size: 10px;
        font-style: italic;
        text-decoration: underline;
        cursor: pointer;
      }

      .perf-curve-text {
        color: #3c4043;
        font-size: 16px;
        margin-left: 44px;
        margin-bottom: -10px;
      }

      .conf-text {
        margin-bottom: 8px;
        color: #3c4043;
        font-size: 16px;
      }

      .dialog-text {
        font-style: normal;
        text-align: left;
      }

      .dialog-title {
        font-size: 14px;
        font-weight: 500;
      }

      .title-width {
        width: 250px;
        padding-right: 16px;
      }

      .datapoint-info-holder {
        margin: 24px auto;
        max-width: 380px;
        padding: 24px;
      }

      .onboarding-header {
        color: #202124;
        font-size: 22px;
        margin-bottom: 28px;
      }

      .onboarding-text {
        color: #3c4043;
        font-size: 14px;
        margin-bottom: 20px;
      }

      .control-info-header {
        color: #3c4043;
        font-size: 14px;
        font-weight: 500;
        margin-top: 10px;
        margin-bottom: 15px;
      }

      .control-info-text {
        color: #3c4043;
        font-size: 14px;
        margin-bottom: 15px;
        max-width: 460px;
      }

      .button-prefix-label {
        margin: 12px 0 0 12px;
        color: grey;
        font-size: 14px;
      }

      .border-right {
        border-right: 1px solid var(--wit-color-gray300);
      }

      paper-dialog {
        color: #3c4043;
        border-radius: 10px;
        max-width: 600px;
      }

      .main-button.run-button {
        padding: 5px;
        flex-grow: 1;
      }

      .doc-image {
        width: 128px;
        height: 96px;
        border: 1px solid var(--wit-color-gray300);
      }

      .control-divider {
        margin: 5px 0 5px 5px;
        width: 5px;
        border-left: 1px solid var(--wit-color-gray300);
      }

      .optimization-radio {
        display: block;
        padding: 7px;
      }

      .optimization-radio-group {
        display: flex;
        flex-grow: 1;
        flex-direction: column;
      }

      .infer-info {
        margin-left: 30px;
      }

      .scroll-x {
        overflow-x: auto;
      }

      .perf-table-clickable {
        cursor: pointer;
      }

      .perf-table-title-row {
        background: white;
        width: 100%;
        display: flex;
        border-bottom: 1px solid var(--wit-color-gray300);
        min-height: 52px;
        justify-content: space-between;
      }
      .perf-table-title {
        color: #3c4043;
        font-size: 18px;
        margin-left: 14px;
        margin-top: 16px;
      }
      .perf-table-sort-menu {
        margin-top: -10px;
      }
      .perf-table-header {
        background: white;
        width: 100%;
        font-weight: 500;
        color: #80868b;
        font-size: 14px;
        line-height: 16px;
        letter-spacing: 0.25;
        display: flex;
        border-bottom: 1px solid var(--wit-color-gray300);
        min-height: min-content;
        padding-top: 12px;
        padding-bottom: 4px;
      }

      .perf-table-entries-holder {
        overflow-y: overlay;
        flex-grow: 1;
      }

      .perf-table-entry {
        background: white;
        color: #3c4043;
        font-size: 14px;
        border-bottom: solid 1px var(--wit-color-gray300);
      }

      .perf-table-entry.perf-table-entry-trivial {
        background: #f4f4f4;
      }

      .perf-table-entry-expanded {
        display: flex;
        flex-wrap: wrap;
        width: 100%;
        margin: 0 12px;
        border-left: 1px solid var(--wit-color-gray300);
        border-bottom: 1px solid var(--wit-color-gray300);
        border-right: 1px solid var(--wit-color-gray300);
        background: white;
      }

      .perf-table-row {
        width: 100%;
        display: flex;
        background: white;
        position: relative;
      }

      .perf-table-row-expanded {
        width: 100%;
        display: flex;
        border-bottom: 1px solid var(--wit-color-gray300);
        border-top: 1px solid var(--wit-color-gray300);
        border-radius: 2px;
        box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.3),
          0 1px 3px 1px rgba(60, 64, 67, 0.15);
        background: white;
        position: relative;
      }

      .perf-table-text-entry {
        height: 40px;
        padding-top: 16px;
      }
      .perf-table-num-entry {
        height: 40px;
        padding-top: 16px;
        text-align: right;
      }
      .perf-table-arrow {
        min-width: 40px;
        width: 40px;
        margin-top: 8px;
      }
      .perf-table-val {
        width: 30%;
      }
      .perf-table-count {
        width: 10%;
        margin-right: 20px;
        text-align: right;
      }
      .perf-table-model {
        min-width: 100px;
        width: 100px;
      }
      .perf-table-model-single {
        display: none;
      }
      .perf-table-threshold {
        width: 280px;
        min-width: 280px;
        text-align: center;
      }
      .perf-table-error {
        width: 15%;
        text-align: right;
      }
      .perf-table-sq-error {
        width: 15%;
        text-align: right;
        margin-right: 20px;
      }
      .perf-table-fp {
        width: 15%;
        text-align: right;
      }
      .perf-table-fn {
        width: 15%;
        text-align: right;
      }
      .perf-table-acc {
        width: 15%;
        text-align: right;
        margin-right: 20px;
      }
      .perf-table-f1 {
        width: 10%;
        text-align: right;
        margin-right: 20px;
      }
      .perf-button {
        margin-top: 10px;
      }

      .perf-sort-box {
        display: flex;
        flex-direction: row-reverse;
      }
      .counterfactual-toggle {
        margin: 4px 4px 4px 6px;
        padding-top: 4px;
        --paper-toggle-button-checked-bar-color: #81c995;
      }
      .counterfactual-delta {
        display: flex;
        margin-right: 6px;
      }
      .counterfactual-delta label {
        padding-top: 10px;
      }
      .counterfactual-delta paper-slider {
        height: 40px;
      }
      .datapoint-button {
        color: #202124;
        background: #fde293;
      }
      .infer-button {
        color: white;
        background: #128eaf;
      }
      .flex-grow {
        flex-grow: 1;
      }
      .flex-row-reverse {
        flex-direction: row-reverse;
      }
      .threshold-info-holder {
        margin-top: -2px;
      }
      .tabs {
        padding-left: 32px;
        text-transform: none;
      }
      .rotated-icon {
        transform: rotate(270deg);
      }
      .datapoint-control-button {
        width: 28px;
        height: 28px;
        padding: 4px;
        margin-top: 4px;
      }
      .pd-holder {
        position: relative;
        width: 300px;
      }
      .pd-y-label {
        color: #5f6368;
        font-size: 12px;
        left: -20px;
        padding: 0px;
        position: absolute;
        top: 80px;
        transform: rotate(270deg);
      }
      .pd-x-label {
        bottom: 0;
        color: #5f6368;
        font-size: 12px;
        overflow: hidden;
        padding: 0 0 0 40px;
        position: absolute;
        text-align: center;
        text-overflow: ellipsis;
        width: 100%;
        white-space: nowrap;
      }
      paper-toggle-button {
        font-size: 14px;
        --paper-toggle-button-checked-button-color: white;
        --paper-toggle-button-label-color: #3c4043;
      }
      .button-and-spinner-holder {
        margin-top: 4px;
        position: relative;
      }
      .sort-spinner {
        position: absolute;
        top: 8px;
        left: 8px;
      }
      #attributionLegend {
        width: 160px;
        height: 32px;
        margin-top: 8px;
        margin-right: 8px;
      }
    </style>
    <tf-plugin-dialog id="initialDialog"></tf-plugin-dialog>
    <paper-dialog
      id="inferencesettings"
      class="inference-settings"
      opened="[[!local]]"
    >
      <tf-inference-panel
        inference-address="{{inferenceAddress}}"
        model-name="{{modelName}}"
        examples-path="{{examplesPath}}"
        model-type="{{modelType}}"
        model-version="{{modelVersion}}"
        model-signature="{{modelSignature}}"
        max-examples="{{maxExamples}}"
        label-vocab-path="{{labelVocabPath}}"
        multi-class="{{multiClass}}"
        sampling-odds="{{samplingOdds}}"
        sequence-examples="{{sequenceExamples}}"
        max-classes-to-display="{{maxInferenceEntriesPerRun}}"
        use-predict-api="{{usePredictApi}}"
        predict-output-tensor="{{predictOutputTensor}}"
        predict-input-tensor="{{predictInputTensor}}"
      >
      </tf-inference-panel>
      <div class="accept-button-holder">
        <paper-button
          on-tap="getExamplesAndCloseSettings_"
          class="main-button"
          disabled$="[[shouldDisableGetExamplesButton_(examplesPath, maxExamples)]]"
        >
          Accept
        </paper-button>
        <paper-button dialog-dismiss class="control-button"
          >Cancel</paper-button
        >
      </div>
    </paper-dialog>
    <paper-dialog id="deletedialog">
      <p>Are you sure you want to delete the selected datapoint?</p>
      <div class="buttons">
        <paper-button dialog-dismiss class="control-button"
          >Cancel</paper-button
        >
        <paper-button
          dialog-confirm
          autofocus
          on-tap="deleteDatapoint_"
          class="main-button"
          >Delete</paper-button
        >
      </div>
    </paper-dialog>
    <paper-dialog id="distancedialog">
      <h2>Show similarity to selected datapoint</h2>
      <paper-input
        value="{{facetDistFeatureName}}"
        label="Metric name"
        class="datapoint-control-filter-input"
      >
      </paper-input>
      <div class="radiolabel">Distance type</div>
      <paper-radio-group class="dist-switch" selected="{{facetDistSwitch}}">
        <paper-radio-button
          class="dist-radio"
          name="L1"
          disabled$="[[customDistanceFunctionSet]]"
          >L1</paper-radio-button
        >
        <paper-radio-button
          class="dist-radio"
          name="L2"
          disabled$="[[customDistanceFunctionSet]]"
          >L2</paper-radio-button
        >
        <paper-radio-button
          class="dist-radio"
          name="Custom"
          hidden$="[[!customDistanceFunctionSet]]"
          >User-specified</paper-radio-button
        >
      </paper-radio-group>
      <paper-dropdown-menu
        label="Apply to datapoints visualization"
        class="threshold-dropdown distance-vis-dropdown"
      >
        <paper-listbox
          slot="dropdown-content"
          selected="{{facetDistSetting}}"
          attr-for-selected="name"
        >
          <paper-item name="colorBy">Color By</paper-item>
          <paper-item name="horizontalFacet">X-Axis Binning</paper-item>
          <paper-item name="verticalFacet">Y-Axis Binning</paper-item>
          <paper-item name="horizontalPosition">X-Axis Scatter</paper-item>
          <paper-item name="verticalPosition">Y-Axis Scatter</paper-item>
        </paper-listbox>
      </paper-dropdown-menu>
      <div class="buttons">
        <paper-button dialog-dismiss class="control-button"
          >Cancel</paper-button
        >
        <paper-button
          dialog-confirm
          autofocus
          on-tap="requestAddDistanceMetric"
          class="main-button"
          >Apply</paper-button
        >
      </div>
    </paper-dialog>
    <div class="dashboard-layout">
      <div class="main-vertical">
        <div class="main-content">
          <div class="main-bottom-bar">
            <div class="datapoint-left-controls-holder">
              <paper-tabs class="tabs" noink selected="{{sideTabSelected}}">
                <paper-tab>Datapoint editor</paper-tab>
                <paper-tab
                  >[[getPerformanceTabTitle(modelType, multiClass)]]</paper-tab
                >
                <paper-tab>Features</paper-tab>
              </paper-tabs>
            </div>
            <div class="datapoint-right-controls-holder">
              <a
                target="_blank"
                class="control"
                href="https://github.com/tensorflow/tensorboard/tree/master/tensorboard/plugins/interactive_inference/README.md"
                rel="noopener noreferrer"
              >
                <paper-icon-button
                  icon="help-outline"
                  class="settings-button"
                  title="What-If Tool documentation"
                ></paper-icon-button>
              </a>
              <paper-icon-button
                icon="settings"
                on-tap="settingsClicked_"
                class="settings-button control"
                title="What-If Tool settings"
                disabled$="[[local]]"
              ></paper-icon-button>
              <div class="example-status">[[exampleStatusStr]]</div>
            </div>
          </div>
          <iron-pages class="side-tabs" selected="{{sideTabSelected}}">
            <div class="datapoint-tab">
              <div class="side-holder" id="side">
                <div class="side-content">
                  <div class="heading-and-card">
                    <button class="heading" on-tap="toggleContextTools">
                      Visualize
                      <div class="right-side right-side-performance-tab">
                        <iron-icon
                          icon="[[getExpandCollapseIcon(openedContextTools)]]"
                          class="expand-collapse-button"
                        ></iron-icon>
                      </div>
                    </button>
                    <iron-collapse
                      class="no-padding-card"
                      id="collapsecontexttools"
                      opened="{{openedContextTools}}"
                    >
                      <paper-radio-group selected="{{visMode}}">
                        <paper-radio-button name="dive"
                          >Datapoints</paper-radio-button
                        >
                        <paper-radio-button name="pd"
                          >Partial dependence plots</paper-radio-button
                        >
                      </paper-radio-group>
                      <div class="flex-wrap">
                        <div title="Select a datapoint to use this feature">
                          <paper-toggle-button
                            class="counterfactual-toggle"
                            checked="{{showNearestCounterfactual}}"
                            disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                          >
                            Show nearest counterfactual datapoint
                          </paper-toggle-button>
                        </div>
                        <paper-radio-group
                          selected="{{nearestCounterfactualDist}}"
                        >
                          <paper-radio-button
                            name="L1"
                            disabled$="[[customDistanceFunctionSet]]"
                            >L1</paper-radio-button
                          >
                          <paper-radio-button
                            name="L2"
                            disabled$="[[customDistanceFunctionSet]]"
                            >L2</paper-radio-button
                          >
                          <paper-radio-button
                            name="Custom"
                            hidden$="[[!customDistanceFunctionSet]]"
                            >User-specified</paper-radio-button
                          >
                        </paper-radio-group>
                        <template is="dom-if" if="[[isRegression_(modelType)]]">
                          <div
                            title="Minimum distance in inferred value to consider counterfactual"
                            class="counterfactual-delta"
                          >
                            <paper-slider
                              pin
                              value="{{minCounterfactualValueDist}}"
                              max="[[maxCounterfactualValueDist]]"
                            ></paper-slider>
                            <label>Delta</label>
                          </div>
                        </template>
                        <paper-dropdown-menu
                          label="Model:"
                          no-label-float
                          class="counterfactual-dropdown"
                          hidden$="[[shouldHideCounterfactualModelSelector_(parsedModelNames)]]"
                        >
                          <paper-listbox
                            class="dropdown-content"
                            slot="dropdown-content"
                            selected="{{nearestCounterfactualModelIndex}}"
                          >
                            <template
                              is="dom-repeat"
                              items="[[parsedModelNames]]"
                            >
                              <paper-item
                                >[[getCounterfactualModelName_(item)]]</paper-item
                              >
                            </template>
                          </paper-listbox>
                        </paper-dropdown-menu>
                        <paper-icon-button
                          icon="info-outline"
                          class="info-icon no-padding"
                          on-tap="openDialog"
                        >
                        </paper-icon-button>
                        <paper-dialog
                          class="dialog-text"
                          horizontal-align="auto"
                          vertical-align="auto"
                        >
                          <div class="dialog-title">
                            Nearest counterfactual (neighbor of different
                            classification)
                          </div>
                          <div>
                            Compares the selected datapoint with its nearest
                            neighbor from a different classification using L1 or
                            L2 distance. If a custom distance function is set,
                            it uses that function instead.
                          </div>
                          <div>
                            <template
                              is="dom-if"
                              if="[[isRegression_(modelType)]]"
                              restamp
                            >
                              For regression, a neighbor point is considered as
                              a different classification if the difference in
                              inferred value is equal or greater than the
                              selected delta.<br />
                              Delta is initialized to the standard deviation of
                              the inferred values.
                            </template>
                          </div>
                        </paper-dialog>
                      </div>
                      <div title="Select a datapoint to use this feature">
                        <div class="flex">
                          <paper-button
                            class="control-button datapoint-button"
                            disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                            on-tap="showDistanceClicked_"
                            alt="Show similarity to selected datapoint"
                            title="Show similarity to selected datapoint"
                          >
                            Show similarity to selected datapoint
                          </paper-button>
                          <paper-icon-button
                            icon="info-outline"
                            class="info-icon cf-info-icon no-padding"
                            on-tap="openDialog"
                          >
                          </paper-icon-button>
                          <paper-dialog
                            class="dialog-text"
                            horizontal-align="auto"
                            vertical-align="auto"
                          >
                            <div class="dialog-title">
                              Show similarity to selected datapoint
                            </div>
                            <div>
                              Calculates the distance between the selected
                              datapoint and all other datapoints and shows this
                              in the datapoints visualization.
                            </div>
                          </paper-dialog>
                        </div>
                      </div>
                    </iron-collapse>
                  </div>
                  <div class="heading-and-card editor-heading-and-card">
                    <button class="heading">
                      [[getDatapointEditorTitle(selectedExampleNum,
                      comparedIndices)]]
                    </button>
                    <div class="no-padding-card">
                      <div
                        class="datapoint-controls-holder datapoint-control-buttons-holder"
                      >
                        <div class="datapoint-left-controls-holder">
                          <paper-icon-button
                            class="datapoint-control-button"
                            icon="chevron-left"
                            disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                            on-tap="selectPrevDatapoint_"
                            alt="select previous datapoint"
                            title="Select previous datapoint"
                          >
                          </paper-icon-button>
                          <paper-icon-button
                            class="datapoint-control-button"
                            icon="chevron-right"
                            disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                            on-tap="selectNextDatapoint_"
                            alt="select next datapoint"
                            title="Select next datapoint"
                          >
                          </paper-icon-button>
                          <div title="Edit a datapoint to use this feature">
                            <paper-icon-button
                              class="datapoint-control-button"
                              icon="history"
                              on-tap="resetDatapoint_"
                              alt="undo changes"
                              title="Undo changes"
                              disabled$="[[shouldDisableReset_(selectedExampleAndInference.changed)]]"
                            >
                            </paper-icon-button>
                          </div>
                          <div title="Select a datapoint to use this feature">
                            <paper-icon-button
                              class="datapoint-control-button"
                              icon="content-copy"
                              disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                              on-tap="copyDatapoint_"
                              alt="duplicate datapoint"
                              title="Duplicate datapoint"
                            >
                            </paper-icon-button>
                          </div>
                          <div title="Select a datapoint to use this feature">
                            <paper-icon-button
                              class="datapoint-control-button"
                              icon="delete"
                              disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                              on-tap="deleteDatapointDialog_"
                              alt="delete datapoint"
                              title="Delete datapoint"
                            >
                            </paper-icon-button>
                          </div>
                          <div class="control-divider"></div>
                          <paper-input
                            value="{{featureSearchValue}}"
                            label="Search features"
                            class="datapoint-control-filter-input feature-search-input"
                            disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                            no-label-float
                          >
                            <iron-icon
                              icon="icons:search"
                              slot="prefix"
                            ></iron-icon>
                          </paper-input>
                          <div
                            class="flex"
                            hidden="[[!hasAttributions_(attributions)]]"
                          >
                            <div class="control-divider"></div>
                            <paper-dropdown-menu
                              label="Feature sort order"
                              class="short-dropdown"
                              no-label-float
                            >
                              <paper-listbox
                                slot="dropdown-content"
                                selected="{{exampleFeatureSortOrder}}"
                                attr-for-selected="name"
                              >
                                <paper-item name="alphabetical"
                                  >Alphabetical</paper-item
                                >
                                <paper-item name="attribution"
                                  >Attributions</paper-item
                                >
                                <paper-item name="reverse-attribution"
                                  >Reverse attributions</paper-item
                                >
                              </paper-listbox>
                            </paper-dropdown-menu>
                            <svg id="attributionLegend"></svg>
                          </div>
                        </div>
                        <div class="datapoint-right-controls-holder"></div>
                      </div>
                      <template
                        is="dom-if"
                        if="[[hasSelected(selectedExampleAndInference)]]"
                      >
                        <div class="example-and-inference-holder">
                          <vz-example-viewer
                            class="example-holder"
                            json="{{selectedExampleAndInference.example}}"
                            compare-json="{{counterfactualExampleAndInference.example}}"
                            on-example-change="exampleChange_"
                            id="viewer"
                            display-mode="[[exampleDisplayMode]]"
                            feature-search-value="{{featureSearchValue}}"
                            compare-title="[[compareTitle]]"
                            saliency="[[attribution]]"
                            show-saliency
                            readonly="[[!areExamplesEditable_(modelName, inferenceAddress)]]"
                            sort-order="[[exampleFeatureSortOrder]]"
                            min-sal="[[minAttribution]]"
                            max-sal="[[maxAttribution]]"
                            colors="[[attributionColorScale]]"
                          >
                          </vz-example-viewer>
                        </div>
                      </template>
                      <template
                        is="dom-if"
                        if="[[!hasSelected(selectedExampleAndInference)]]"
                      >
                        <div class="datapoint-info-holder">
                          <div class="datapoint-info-content">
                            <div class="flex space-between">
                              <div class="onboarding-header">
                                Select a datapoint to begin exploring model
                                behavior for your selection.
                              </div>
                            </div>
                            <div class="onboarding-text">
                              <span class="bold">Edit and Infer:</span>
                              Edit your datapoint here and run inference in the
                              Infer table to see differences in model behavior.
                            </div>
                            <div class="onboarding-text">
                              <span class="bold">Visualize:</span>
                              Switch between visualizing datapoints and
                              exploring partial dependence plots to gain
                              insights into your model's behavior. Explore
                              counterfactuals or see how similar (or different)
                              the rest of your dataset is from your selection.
                            </div>
                          </div>
                        </div>
                      </template>
                    </div>
                  </div>
                  <div class="inference-section-holder">
                    <div class="inference-section">
                      <button
                        class="inference-header heading"
                        on-tap="toggleInferenceResults"
                      >
                        <div class="flex">
                          <div>
                            [[getInferTitle(selectedExampleNum,
                            comparedIndices)]]
                          </div>
                          <div class="right-side right-side-performance-tab">
                            <iron-icon
                              icon="[[getExpandCollapseIcon(openedInferenceResults)]]"
                              class="expand-collapse-button"
                            ></iron-icon>
                          </div>
                        </div>
                      </button>
                      <iron-collapse
                        class="no-padding-card"
                        id="collapseinference"
                        opened="{{openedInferenceResults}}"
                      >
                        <div title="Edit a datapoint to use this feature">
                          <paper-button
                            on-tap="inferClicked_"
                            class="control-button infer-button flex-grow"
                            disabled$="[[shouldDisableInferButton_(examplesAndInferences, modelName, inferenceAddress, updatedExample)]]"
                          >
                            Run inference
                          </paper-button>
                        </div>
                        <div class="flex">
                          <template
                            is="dom-if"
                            if="[[hasSelected(selectedExampleAndInference)]]"
                          >
                            <tf-inference-viewer
                              class="inference-viewer"
                              inferences="[[selectedExampleAndInference.inferences]]"
                              id$="[[getInferenceHolderId_()]]"
                              model-type="[[modelType]]"
                              model-names="[[parsedModelNames]]"
                              max-entries-per-run="[[maxInferenceEntriesPerRun]]"
                            >
                            </tf-inference-viewer>
                          </template>
                          <template
                            is="dom-if"
                            if="[[counterfactualExampleAndInference]]"
                          >
                            <tf-inference-viewer
                              class="inference-viewer compare-inference-viewer"
                              inferences="[[counterfactualExampleAndInference.inferences]]"
                              model-type="[[modelType]]"
                              model-names="[[parsedModelNames]]"
                              max-entries-per-run="[[maxInferenceEntriesPerRun]]"
                            >
                            </tf-inference-viewer>
                          </template>
                        </div>
                      </iron-collapse>
                    </div>
                  </div>
                </div>
                <div class="resizer" id="resizer">
                  <iron-icon icon="av:pause" class="resize-icon"></iron-icon>
                </div>
              </div>
              <div class="center" slot="center" id="center">
                <facets-dive
                  id="dive"
                  data="[[visdata]]"
                  selected-indices="[[selected]]"
                  compared-indices="[[comparedIndices]]"
                  on-selected-indices-changed="selectedIndicesChanged_"
                  on-stats-changed="statsChanged_"
                  hide-info-card="true"
                  sprite-image-width="32"
                  sprite-image-height="32"
                  fit-grid-aspect-ratio-to-viewport="true"
                  stable-colors="true"
                >
                </facets-dive>
                <div id="noexamples" class="noexamples info-text">
                  Datapoints and their inference results will be displayed here.
                </div>
                <paper-spinner-lite
                  id="spinner"
                  hidden="[[spinnerHidden_]]"
                  active
                ></paper-spinner-lite>
                <div class="feature-container-holder" id="partialplotholder">
                  <div class="pd-plots-header">
                    <div class="flex">
                      <div class="pd-info-text">Partial Dependence Plots</div>
                      <paper-icon-button
                        icon="info-outline"
                        class="info-icon pd-info-icon no-padding"
                        on-tap="openDialog"
                      >
                      </paper-icon-button>
                      <paper-dialog
                        class="dialog-text"
                        horizontal-align="auto"
                        vertical-align="auto"
                      >
                        <div class="dialog-title">Partial Dependence Plots</div>
                        <div>
                          Partial dependence plots visualize the change in
                          inference results for every feature, as the value for
                          that feature is changed to different valid values.
                        </div>
                        <div>
                          For numeric features, you can set the minimum and
                          maximum values to plot.
                        </div>
                        <div>
                          For string features, the most popular feature values
                          are shown as alternatives to the feature value for the
                          selected datapoint.
                        </div>
                        <div>
                          For features with multiple feature values per
                          datapoint, a single plot is shown for for each feature
                          value in the selected datapoint. You can override
                          which feature values have plots created for them by
                          specifying the indices to shown partial dependence
                          plots for, if the datapoint contains multiple feature
                          values for a feature.
                        </div>
                        <div>
                          When the global toggle is turned on, the plots show
                          the average effect of repeatedly changing a single
                          feature across all datapoints. When it is turned off,
                          the plots show the effect of a repeatedly changing a
                          single feature on the selected datapoint.
                        </div>
                      </paper-dialog>
                    </div>
                    <div class="button-and-spinner-holder">
                      <paper-button
                        class="control-button datapoint-button"
                        disabled$="[[shouldDisableSortFeaturesButton(partialDepPlotEligibleFeatures, isSortingEligibleFeatures)]]"
                        on-tap="sortPdFeatures_"
                        alt="Sort features by interestingness"
                        title="Sort features by interestingness"
                      >
                        Sort features by interestingness
                      </paper-button>
                      <paper-spinner-lite
                        class="sort-spinner"
                        hidden="[[!isSortingEligibleFeatures]]"
                        active
                      ></paper-spinner-lite>
                    </div>
                    <paper-toggle-button
                      class="pd-toggle"
                      checked="{{globalPdPlots}}"
                      on-change="hideAllPdElements_"
                      disabled$="[[!hasSelected(selectedExampleAndInference)]]"
                    >
                      Global partial dependence plots
                    </paper-toggle-button>
                  </div>
                  <template
                    is="dom-if"
                    if="[[!areTherePdPlotFeatures_(partialDepPlotEligibleFeatures)]]"
                  >
                    <div class="pd-no-features-text">
                      The loaded dataset has no features to show partial
                      dependence plots for.
                    </div>
                  </template>
                  <div class="pdplots-holder">
                    <template
                      is="dom-repeat"
                      items="[[partialDepPlotEligibleFeatures]]"
                    >
                      <div
                        class="feature-container"
                        data-feature-name$="[[item.name]]"
                      >
                        <div class$="[[getPerfTableEntryClass(item)]]">
                          <div class="perf-table-arrow">
                            <paper-icon-button
                              class="pd-row-arrow rotated-icon"
                              icon="arrow-drop-down"
                              on-tap="categoryPaneClicked"
                            ></paper-icon-button>
                          </div>
                          <div
                            class="perf-table-val perf-table-clickable tf-category-pane perf-table-text-entry"
                            on-tap="categoryPaneClicked"
                          >
                            [[item.name]]
                          </div>
                        </div>
                        <div
                          class="pd-entry-container perf-table-entry-expanded"
                          hidden
                        >
                          <div
                            class="pd-input-container"
                            hidden$="[[shouldHidePdInputContainer(item, selected)]]"
                          >
                            <div
                              class="range-input-container"
                              hidden$="[[item.samples]]"
                            >
                              <div
                                class="info-text"
                                title="The range of values to test (default values are automatically inferred)."
                              >
                                Set range of values to test
                              </div>
                              <div class="flex">
                                <input
                                  type="number"
                                  class="style-input x-min pd-range-control"
                                  value="[[item.observedMin]]"
                                  title="The minimum value to test (default value is automatically inferred)."
                                  on-input="pdInputChanged"
                                />
                                <div class="pd-range-hyphen">-</div>
                                <input
                                  type="number"
                                  class="style-input x-max pd-range-control"
                                  value="[[item.observedMax]]"
                                  title="The maximum value to test (default value is automatically inferred)."
                                  on-input="pdInputChanged"
                                />
                              </div>
                            </div>
                            <div
                              class="feature-index-container"
                              hidden$="[[shouldHideFeatureIndicesSelector(item.name, selected)]]"
                              title="An optional printer-page-style pattern like '0,2,4-6' to select the indices of the feature values to generate plots for. Useful for features with many repeated fields."
                            >
                              <div class="info-text">
                                Set feature indices <i>(optional)</i>
                              </div>
                              <input
                                type="text"
                                class="style-input feature-index-pattern pd-range-control"
                                on-input="pdInputChanged"
                              />
                            </div>
                          </div>
                          <div class="tf-category-pane-content"></div>
                        </div>
                      </div>
                    </template>
                  </div>
                </div>
              </div>
            </div>
            <div class="config-tab">
              <div class="config-side-content">
                <div class="heading-and-card">
                  <button
                    class="inference-header heading"
                    on-tap="toggleTrueLabelSetup"
                  >
                    Configure
                    <div class="right-side right-side-performance-tab">
                      <iron-icon
                        icon="[[getExpandCollapseIcon(openedTrueLabel)]]"
                        class="expand-collapse-button"
                      ></iron-icon>
                    </div>
                  </button>
                  <iron-collapse
                    class="card"
                    id="collapsetruelabel"
                    opened="{{openedTrueLabel}}"
                  >
                    <template
                      is="dom-if"
                      if="[[shouldShowLabelDropdown_(stats)]]"
                    >
                      <div class="flex">
                        <paper-dropdown-menu
                          label="Ground Truth Feature"
                          class="threshold-dropdown"
                        >
                          <paper-listbox
                            slot="dropdown-content"
                            selected="{{selectedLabelFeature}}"
                            attr-for-selected="name"
                          >
                            <template
                              is="dom-repeat"
                              items="[[getFeatureList_(stats)]]"
                            >
                              <paper-item name="[[item]]"
                                >[[getFeatureName_(item)]]</paper-item
                              >
                            </template>
                          </paper-listbox>
                        </paper-dropdown-menu>
                        <div>
                          <div class="help-title help-title-margin">
                            What is ground truth?
                          </div>
                          <div class="help-text">
                            <div>
                              The feature that your model is trying to predict.
                              <span class="dialog-link" on-tap="openDialog"
                                >More.
                              </span>
                              <paper-dialog
                                class="dialog-text"
                                horizontal-align="auto"
                                vertical-align="auto"
                              >
                                <div class="dialog-title">
                                  Ground Truth Feature
                                </div>
                                <div>
                                  If the datapoints contain a feature that
                                  represents the ground truth for what the model
                                  is attempting to predict, then selecting that
                                  feature here allows the tool to investigate
                                  the performance of the model by comparing the
                                  model's results to the ground truth feature.
                                </div>
                              </paper-dialog>
                            </div>
                          </div>
                        </div>
                      </div>
                      <template
                        is="dom-if"
                        if="[[shouldShowCostRatio_(selectedLabelFeature, modelType, multiClass)]]"
                      >
                        <div class="flex">
                          <paper-input
                            value="{{incorrectPredCostRatio}}"
                            label="Cost Ratio (FP/FN)"
                            type="number"
                            class="threshold-cost-input"
                          >
                          </paper-input>
                          <div>
                            <div class="help-title help-title-margin">
                              What is cost ratio?
                            </div>
                            <div class="help-text">
                              <div>
                                The cost of false positives relative to false
                                negatives. Required for optimization.
                                <span class="dialog-link" on-tap="openDialog"
                                  >More.
                                </span>
                                <paper-dialog
                                  class="dialog-text"
                                  horizontal-align="auto"
                                  vertical-align="auto"
                                >
                                  <div class="dialog-title">
                                    What is cost ratio?
                                  </div>
                                  <div>
                                    This tells the tool how to optimize the
                                    classification thresholds when you use the
                                    optimization strategy controls.
                                  </div>
                                  <div>
                                    1.00 = false positives are equally as costly
                                    as false negatives.
                                  </div>
                                  <div>
                                    4.00 = false positives are 4 times more
                                    costly than false negatives
                                  </div>
                                  <div>
                                    0.25 = false negatives are 4 times more
                                    costly than false positives.
                                  </div>
                                </paper-dialog>
                              </div>
                            </div>
                          </div>
                        </div>
                      </template>
                      <template
                        is="dom-if"
                        if="[[shouldShowFeatureDropdown_(stats)]]"
                      >
                        <div class="flex">
                          <paper-dropdown-menu
                            label="Slice by"
                            class="threshold-dropdown"
                          >
                            <paper-listbox
                              slot="dropdown-content"
                              selected="{{selectedBreakdownFeature}}"
                              attr-for-selected="name"
                            >
                              <template
                                is="dom-repeat"
                                items="[[getFeatureList_(stats)]]"
                              >
                                <paper-item name="[[item]]"
                                  >[[getFeatureName_(item)]]</paper-item
                                >
                              </template>
                            </paper-listbox>
                          </paper-dropdown-menu>
                          <template
                            is="dom-if"
                            if="[[isNumericFeature_(selectedBreakdownFeature)]]"
                          >
                            <paper-input
                              min="2"
                              value="{{numPrimaryBuckets}}"
                              label="Buckets"
                              type="number"
                              class="num-buckets-input"
                            ></paper-input>
                          </template>
                          <div>
                            <div class="help-title help-title-margin">
                              What does slicing do?
                            </div>
                            <div class="help-text">
                              <div>
                                Shows performance for each value of the selected
                                feature.
                              </div>
                            </div>
                          </div>
                        </div>
                        <div class="flex">
                          <template
                            is="dom-if"
                            if="[[shouldShowSecondFeatureDropdown_(selectedBreakdownFeature)]]"
                          >
                            <paper-dropdown-menu
                              label="Slice by (secondary)"
                              class="threshold-dropdown"
                            >
                              <paper-listbox
                                slot="dropdown-content"
                                selected="{{selectedSecondBreakdownFeature}}"
                                attr-for-selected="name"
                              >
                                <template
                                  is="dom-repeat"
                                  items="[[getFeatureList_(stats)]]"
                                >
                                  <paper-item name="[[item]]"
                                    >[[getFeatureName_(item)]]</paper-item
                                  >
                                </template>
                              </paper-listbox>
                            </paper-dropdown-menu>
                            <template
                              is="dom-if"
                              if="[[isNumericFeature_(selectedSecondBreakdownFeature)]]"
                            >
                              <paper-input
                                min="2"
                                value="{{numSecondaryBuckets}}"
                                label="Buckets"
                                type="number"
                                class="num-buckets-input"
                              ></paper-input>
                            </template>
                          </template>
                        </div>
                      </template>
                    </template>
                  </iron-collapse>
                </div>
                <template
                  is="dom-if"
                  if="[[isBinaryClassification_(modelType, multiClass)]]"
                >
                  <div class="heading-and-card">
                    <button
                      class="inference-header heading"
                      on-tap="toggleExplorerSetup"
                    >
                      Fairness
                      <div class="right-side right-side-performance-tab">
                        <iron-icon
                          icon="[[getExpandCollapseIcon(openedExplorer)]]"
                          class="expand-collapse-button"
                        ></iron-icon>
                      </div>
                    </button>
                    <iron-collapse
                      class="card"
                      id="collapseexplorer"
                      opened="{{openedExplorer}}"
                    >
                      <template
                        is="dom-if"
                        if="[[shouldShowFeatureDropdown_(stats)]]"
                      >
                        <div
                          class="control-info-header help-title-margin-button"
                        >
                          Apply an optimization strategy
                        </div>
                        <div class="control-info-text">
                          Select a strategy to set classification thresholds
                          based on the set cost ratio and data slices. Manually
                          altering thresholds or changing cost ratio will
                          default back to custom thresholds.
                        </div>
                        <paper-radio-group
                          class="optimization-radio-group"
                          selected="{{optimizationSelected}}"
                        >
                          <paper-radio-button
                            name="custom"
                            class="optimization-radio"
                            id="customthresh"
                            >Custom thresholds
                            <paper-icon-button
                              icon="info-outline"
                              class="info-icon thresh-info-icon no-padding"
                              on-tap="openDialog"
                            >
                            </paper-icon-button>
                            <paper-dialog
                              class="dialog-text"
                              horizontal-align="auto"
                              vertical-align="bottom"
                            >
                              <div class="dialog-title">Custom thresholds</div>
                              <div>
                                Set your own thresholds using the threshold
                                sliders.
                              </div>
                            </paper-dialog>
                          </paper-radio-button>
                          <paper-radio-button
                            name="unaware"
                            class="optimization-radio"
                            >Single threshold
                            <paper-icon-button
                              icon="info-outline"
                              class="info-icon thresh-info-icon no-padding"
                              on-tap="openDialog"
                            >
                            </paper-icon-button>
                            <paper-dialog
                              class="dialog-text"
                              horizontal-align="auto"
                              vertical-align="bottom"
                            >
                              <div class="dialog-title">Single threshold</div>
                              <div>
                                Optimize a single threshold for all datapoints
                                based on the specified cost ratio.
                              </div>
                            </paper-dialog>
                          </paper-radio-button>
                          <paper-radio-button
                            name="demoparity"
                            class="optimization-radio"
                            disabled$="[[!shouldShowFeaturePerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]"
                            >Demographic parity
                            <paper-icon-button
                              icon="info-outline"
                              class="info-icon thresh-info-icon no-padding"
                              on-tap="openDialog"
                            >
                            </paper-icon-button>
                            <paper-dialog
                              class="dialog-text"
                              horizontal-align="auto"
                              vertical-align="bottom"
                            >
                              <div class="dialog-title">Demographic parity</div>
                              <div>
                                Optimize a threshold per slice based on the
                                specified cost ratio, ensuring the different
                                slices achieve demographic party.
                              </div>
                              <div>
                                Demographic parity means that similar
                                percentages of datapoints from each slice are
                                predicted as positive classifications.
                              </div>
                            </paper-dialog>
                          </paper-radio-button>
                          <paper-radio-button
                            name="equalopp"
                            class="optimization-radio"
                            disabled$="[[!shouldShowFeaturePerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]"
                            >Equal opportunity
                            <paper-icon-button
                              icon="info-outline"
                              class="info-icon thresh-info-icon no-padding"
                              on-tap="openDialog"
                            >
                            </paper-icon-button>
                            <paper-dialog
                              class="dialog-text"
                              horizontal-align="auto"
                              vertical-align="bottom"
                            >
                              <div class="dialog-title">Equal opportunity</div>
                              <div>
                                Optimize a threshold per slice based on the
                                specified cost ratio, ensuring the different
                                slices achieve equal opportunity.
                              </div>
                              <div>
                                Equal opportunity means that among those
                                datapoints with the positive ground truth label,
                                there is a similar percentage of positive
                                predictions in each slice.
                              </div>
                            </paper-dialog>
                          </paper-radio-button>
                          <paper-radio-button
                            name="equalacc"
                            class="optimization-radio"
                            disabled$="[[!shouldShowFeaturePerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]"
                            >Equal accuracy
                            <paper-icon-button
                              icon="info-outline"
                              class="info-icon thresh-info-icon no-padding"
                              on-tap="openDialog"
                            >
                            </paper-icon-button>
                            <paper-dialog
                              class="dialog-text"
                              horizontal-align="auto"
                              vertical-align="bottom"
                            >
                              <div class="dialog-title">Equal accuracy</div>
                              <div>
                                Optimize a threshold per slice based on the
                                specified cost ratio, ensuring the different
                                slices achieve equal accuracy.
                              </div>
                              <div>
                                Equal accuracy means that there is a similar
                                percentage of correct predictions in each slice.
                              </div>
                            </paper-dialog>
                          </paper-radio-button>
                          <paper-radio-button
                            name="group"
                            class="optimization-radio"
                            disabled$="[[!shouldShowFeaturePerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]"
                            >Group thresholds
                            <paper-icon-button
                              icon="info-outline"
                              class="info-icon thresh-info-icon no-padding"
                              on-tap="openDialog"
                            >
                            </paper-icon-button>
                            <paper-dialog
                              class="dialog-text"
                              horizontal-align="auto"
                              vertical-align="bottom"
                            >
                              <div class="dialog-title">Group thresholds</div>
                              <div>
                                Optimize a separate threshold for each slice
                                based on the specified cost ratio.
                              </div>
                            </paper-dialog>
                          </paper-radio-button>
                        </paper-radio-group>
                      </template>
                    </iron-collapse>
                  </div>
                </template>
              </div>
              <div class="config-main-content">
                <template
                  is="dom-if"
                  if="[[isBinaryClassification_(modelType, multiClass)]]"
                  restamp
                >
                  <div class="perf-table-title-row">
                    <div class="flex">
                      <div class="perf-table-title">
                        [[getPerfTableTitle(selectedBreakdownFeature,
                        selectedSecondBreakdownFeature, optimizationSelected,
                        featureValueThresholds)]]
                      </div>
                      <paper-icon-button
                        icon="info-outline"
                        class="info-icon performance-info-icon no-padding"
                        on-tap="openDialog"
                      >
                      </paper-icon-button>
                      <paper-dialog
                        class="dialog-text"
                        horizontal-align="auto"
                        vertical-align="auto"
                      >
                        <div class="dialog-title">
                          Classification Performance Table
                        </div>
                        <div>
                          Set the ground truth feature to explore model
                          performance including ROC curves and confusion
                          matrices.
                        </div>
                        <div>
                          Slice the dataset by features and explore model
                          performance by slice.
                        </div>
                        <div>
                          Use the fairness optimization strategies and see the
                          impact on the thresholds and performance of the
                          individual slices.
                        </div>
                      </paper-dialog>
                    </div>
                    <div class="perf-sort-box">
                      <div>
                        <paper-icon-button
                          icon="unfold-more"
                          class="perf-button"
                          on-tap="expandAllPerformance"
                          alt="expand all slices"
                          title="Expand all slices"
                        >
                        </paper-icon-button>
                        <paper-icon-button
                          icon="unfold-less"
                          class="perf-button"
                          on-tap="collapseAllPerformance"
                          alt="collapse all slices"
                          title="Collapse all slices"
                        >
                        </paper-icon-button>
                      </div>
                      <paper-dropdown-menu
                        label="Sort by"
                        class="threshold-dropdown perf-table-sort-menu"
                      >
                        <paper-listbox
                          slot="dropdown-content"
                          selected="{{selectedFeatureSort}}"
                          attr-for-selected="name"
                        >
                          <template
                            is="dom-repeat"
                            items="[[getFeatureSortBy(modelType, multiClass)]]"
                          >
                            <paper-item name="[[item]]">[[item]]</paper-item>
                          </template>
                        </paper-listbox>
                      </paper-dropdown-menu>
                    </div>
                  </div>
                  <div class="perf-table-header">
                    <div class="perf-table-arrow">
                      <iron-icon class="expand-collapse-button"></iron-icon>
                    </div>
                    <div class="perf-table-val">Feature Value</div>
                    <div class="perf-table-count">Count</div>
                    <div class$="[[getPerfTableModelClass(numModels)]]">
                      Model
                    </div>
                    <div class="perf-table-threshold flex">
                      <div>Threshold</div>
                      <div class="threshold-info-holder">
                        <paper-icon-button
                          icon="info-outline"
                          class="info-icon threshold-info-icon no-padding"
                          on-tap="openDialog"
                        >
                        </paper-icon-button>
                        <paper-dialog
                          class="dialog-text"
                          horizontal-align="auto"
                          vertical-align="auto"
                        >
                          <div class="dialog-title">
                            Exploring Classification Performance
                          </div>
                          <div>
                            Use this slider to adjust the classification
                            threshold for this slice. Inference values at or
                            above this threshold are considered a positive
                            classification, while inference values below this
                            threshold are considered a negative classification.
                          </div>
                        </paper-dialog>
                      </div>
                    </div>
                    <div class="perf-table-fp">False Positives (%)</div>
                    <div class="perf-table-fn">False Negatives (%)</div>
                    <div class="perf-table-acc">Accuracy (%)</div>
                    <div class="perf-table-f1">F1</div>
                  </div>
                  <div class="perf-table-entries-holder">
                    <template
                      is="dom-repeat"
                      items="[[featureValueThresholds]]"
                      as="featureValueThreshold"
                    >
                      <div class="perf-table-entry">
                        <div
                          class$="[[getPerfTableRowClass(featureValueThreshold.opened)]]"
                          data-index$="[[index]]"
                        >
                          <div class="perf-table-arrow">
                            <paper-icon-button
                              class$="[[getExpandCollapsePerfIconClass(featureValueThreshold.opened)]]"
                              icon="arrow-drop-down"
                              on-tap="togglePerfRow"
                            ></paper-icon-button>
                          </div>
                          <div
                            class="perf-table-val perf-table-clickable perf-table-text-entry"
                            on-tap="togglePerfRow"
                          >
                            [[getPrintableValue_(featureValueThreshold)]]
                          </div>
                          <div
                            class="perf-table-count perf-table-clickable perf-table-num-entry"
                            on-tap="togglePerfRow"
                          >
                            [[getFeatureValueCount(inferenceStats_,
                            featureValueThreshold.threshold,
                            featureValueThreshold)]]
                          </div>
                          <div
                            class$="[[getPerfTableModelClass(numModels)]]"
                            on-tap="togglePerfRow"
                          >
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <div
                                class="perf-table-text-entry perf-table-clickable"
                              >
                                [[getModelName_(index)]]
                              </div>
                            </template>
                          </div>
                          <div class="perf-table-threshold">
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <paper-slider
                                class$="[[getSliderClass(index)]]"
                                editable="true"
                                min="0"
                                max="1"
                                step="0.01"
                                immediate-value="{{item.threshold}}"
                                value="[[item.threshold]]"
                                on-value-changed="refreshInferencesNoRegen_"
                                on-immediate-value-changed="refreshInferencesNoRegen_"
                                on-down="resetOptimizationSelected_"
                              >
                              </paper-slider>
                            </template>
                          </div>
                          <div
                            class="perf-table-fp perf-table-clickable"
                            on-tap="togglePerfRow"
                          >
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getFPModelIndex(inferenceStats_,
                                featureValueThreshold.threshold, index,
                                featureValueThreshold)]]
                              </div>
                            </template>
                          </div>
                          <div
                            class="perf-table-fn perf-table-clickable"
                            on-tap="togglePerfRow"
                          >
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getFNModelIndex(inferenceStats_,
                                featureValueThreshold.threshold, index,
                                featureValueThreshold)]]
                              </div>
                            </template>
                          </div>
                          <div
                            class="perf-table-acc perf-table-clickable"
                            on-tap="togglePerfRow"
                          >
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getAccuracyModelIndex(inferenceStats_,
                                featureValueThreshold.threshold, index,
                                featureValueThreshold)]]
                              </div>
                            </template>
                          </div>
                          <div
                            class="perf-table-f1 perf-table-clickable"
                            on-tap="togglePerfRow"
                          >
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getF1ModelIndex(inferenceStats_,
                                featureValueThreshold.threshold, index,
                                featureValueThreshold)]]
                              </div>
                            </template>
                          </div>
                        </div>
                      </div>
                      <iron-collapse opened="{{featureValueThreshold.opened}}">
                        <div class="perf-table-entry-expanded flex-row-reverse">
                          <template
                            is="dom-if"
                            if="[[shouldShowFeaturePerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]"
                          >
                            <div class="perfs-holder">
                              <div class="perf-holder">
                                <div class="perf-curve-text">
                                  ROC curve
                                  <paper-icon-button
                                    icon="info-outline"
                                    class="info-icon threshold-info-icon no-padding"
                                    on-tap="openDialog"
                                  >
                                  </paper-icon-button>
                                  <paper-dialog
                                    class="dialog-text"
                                    horizontal-align="right"
                                    vertical-align="bottom"
                                  >
                                    <div class="dialog-title">ROC curve</div>
                                    <div>
                                      A receiver operating characteristic (ROC)
                                      curve plots the true positive rate (TPR)
                                      against the false positive rate (FPR) at
                                      various classification thresholds.
                                    </div>
                                  </paper-dialog>
                                </div>
                                <div class="perf-curve-x-label">
                                  False positive rate
                                </div>
                                <div class="perf-curve-y-label">
                                  True positive rate
                                </div>
                                <vz-line-chart2
                                  id="[[getRocChartId(index)]]"
                                  x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                  y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                >
                                </vz-line-chart2>
                              </div>
                              <div class="perf-holder">
                                <div class="perf-curve-text">
                                  PR curve
                                  <paper-icon-button
                                    icon="info-outline"
                                    class="info-icon threshold-info-icon no-padding"
                                    on-tap="openDialog"
                                  >
                                  </paper-icon-button>
                                  <paper-dialog
                                    class="dialog-text"
                                    horizontal-align="right"
                                    vertical-align="bottom"
                                  >
                                    <div class="dialog-title">PR curve</div>
                                    <div>
                                      A precision-recall (PR) curve plots
                                      precision against recall at various
                                      classification thresholds.
                                    </div>
                                  </paper-dialog>
                                </div>
                                <div class="perf-curve-x-label">Recall</div>
                                <div class="perf-curve-y-label">Precision</div>
                                <vz-line-chart2
                                  id="[[getPrChartId(index)]]"
                                  x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                  y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                >
                                </vz-line-chart2>
                              </div>
                              <div class="perf-holder">
                                <div class="conf-text">Confusion matrix</div>
                                <template
                                  is="dom-repeat"
                                  items="{{featureValueThreshold.threshold}}"
                                >
                                  <tf-confusion-matrix
                                    counts="[[getConfusionCountsModelIndex(inferenceStats_, featureValueThreshold.threshold, index, featureValueThreshold)]]"
                                    label="[[getConfusionMatrixLabel(index, numModels)]]"
                                    background="[[getConfusionMatrixColor(index)]]"
                                    all-items="[[allConfMatrixLabels]]"
                                  >
                                  </tf-confusion-matrix>
                                </template>
                              </div>
                            </div>
                          </template>
                        </div>
                      </iron-collapse>
                    </template>
                    <template
                      is="dom-if"
                      if="[[shouldShowOverallThresholder_(selectedBreakdownFeature)]]"
                    >
                      <div class="perf-table-entry">
                        <div class="perf-table-row-expanded">
                          <div class="perf-table-arrow">
                            <paper-icon-button
                              icon="arrow-drop-down"
                              on-tap="togglePerfRow"
                              disabled
                            ></paper-icon-button>
                          </div>
                          <div class="perf-table-val perf-table-text-entry">
                            All datapoints
                          </div>
                          <div class="perf-table-count perf-table-num-entry">
                            [[getFeatureValueCount(inferenceStats_,
                            overallThresholds)]]
                          </div>
                          <div class$="[[getPerfTableModelClass(numModels)]]">
                            <template
                              is="dom-repeat"
                              items="{{overallThresholds}}"
                            >
                              <div class="perf-table-text-entry">
                                [[getModelName_(index)]]
                              </div>
                            </template>
                          </div>
                          <div class="perf-table-threshold">
                            <template
                              is="dom-repeat"
                              items="{{overallThresholds}}"
                            >
                              <paper-slider
                                class$="[[getSliderClass(index)]]"
                                editable="true"
                                min="0"
                                max="1"
                                step="0.01"
                                immediate-value="{{item.threshold}}"
                                value="[[item.threshold]]"
                                on-value-changed="refreshInferencesNoRegen_"
                                on-immediate-value-changed="refreshInferencesNoRegen_"
                                on-down="resetOptimizationSelected_"
                              >
                              </paper-slider>
                            </template>
                          </div>
                          <div class="perf-table-fp">
                            <template
                              is="dom-repeat"
                              items="{{overallThresholds}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getFPModelIndex(inferenceStats_,
                                overallThresholds, index)]]
                              </div>
                            </template>
                          </div>
                          <div class="perf-table-fn">
                            <template
                              is="dom-repeat"
                              items="{{overallThresholds}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getFNModelIndex(inferenceStats_,
                                overallThresholds, index)]]
                              </div>
                            </template>
                          </div>
                          <div class="perf-table-acc">
                            <template
                              is="dom-repeat"
                              items="{{overallThresholds}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getAccuracyModelIndex(inferenceStats_,
                                overallThresholds, index)]]
                              </div>
                            </template>
                          </div>
                          <div class="perf-table-f1">
                            <template
                              is="dom-repeat"
                              items="{{overallThresholds}}"
                            >
                              <div class="perf-table-num-entry">
                                [[getF1ModelIndex(inferenceStats_,
                                overallThresholds, index)]]
                              </div>
                            </template>
                          </div>
                        </div>
                      </div>
                      <div class="perf-table-entry-expanded flex-row-reverse">
                        <template
                          is="dom-if"
                          if="[[shouldShowOverallPerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]"
                        >
                          <div class="perfs-holder">
                            <div class="perf-holder">
                              <div class="perf-curve-text">
                                ROC curve
                                <paper-icon-button
                                  icon="info-outline"
                                  class="info-icon threshold-info-icon no-padding"
                                  on-tap="openDialog"
                                >
                                </paper-icon-button>
                                <paper-dialog
                                  class="dialog-text"
                                  horizontal-align="right"
                                  vertical-align="bottom"
                                >
                                  <div class="dialog-title">ROC curve</div>
                                  <div>
                                    A receiver operating characteristic (ROC)
                                    curve plots the true positive rate (TPR)
                                    against the false positive rate (FPR) at
                                    various classification thresholds.
                                  </div>
                                </paper-dialog>
                              </div>
                              <div class="perf-curve-x-label">
                                False positive rate
                              </div>
                              <div class="perf-curve-y-label">
                                True positive rate
                              </div>
                              <vz-line-chart2
                                id="rocchart"
                                x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                              >
                              </vz-line-chart2>
                            </div>
                            <div class="perf-holder">
                              <div class="perf-curve-text">
                                PR curve
                                <paper-icon-button
                                  icon="info-outline"
                                  class="info-icon threshold-info-icon no-padding"
                                  on-tap="openDialog"
                                >
                                </paper-icon-button>
                                <paper-dialog
                                  class="dialog-text"
                                  horizontal-align="right"
                                  vertical-align="bottom"
                                >
                                  <div class="dialog-title">PR curve</div>
                                  <div>
                                    A precision-recall (PR) curve plots
                                    precision against recall at various
                                    classification thresholds.
                                  </div>
                                </paper-dialog>
                              </div>
                              <div class="perf-curve-x-label">Recall</div>
                              <div class="perf-curve-y-label">Precision</div>
                              <vz-line-chart2
                                id="prchart"
                                x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                              >
                              </vz-line-chart2>
                            </div>
                            <div class="perf-holder">
                              <div class="conf-text">Confusion matrix</div>
                              <template
                                is="dom-repeat"
                                items="{{overallThresholds}}"
                              >
                                <tf-confusion-matrix
                                  counts="[[getConfusionCountsModelIndex(inferenceStats_, overallThresholds, index)]]"
                                  label="[[getConfusionMatrixLabel(index, numModels)]]"
                                  background="[[getConfusionMatrixColor(index)]]"
                                  all-items="[[allConfMatrixLabels]]"
                                >
                                </tf-confusion-matrix>
                              </template>
                            </div>
                          </div>
                        </template>
                      </div>
                    </template>
                  </div>
                </template>
                <template
                  is="dom-if"
                  if="[[isMultiClass_(modelType, multiClass)]]"
                  restamp
                >
                  <div class="perf-table-title-row">
                    <div class="flex">
                      <div class="perf-table-title">
                        [[getNoThresholdPerfTableTitle(selectedBreakdownFeature,
                        selectedSecondBreakdownFeature,
                        featureValueThresholds)]]
                      </div>
                      <paper-icon-button
                        icon="info-outline"
                        class="info-icon performance-info-icon no-padding"
                        on-tap="openDialog"
                      >
                      </paper-icon-button>
                      <paper-dialog
                        class="dialog-text"
                        horizontal-align="auto"
                        vertical-align="auto"
                      >
                        <div class="dialog-title">
                          Classification Performance Table
                        </div>
                        <div>
                          Set the ground truth feature to explore model
                          performance including confusion matrices.
                        </div>
                        <div>
                          Slice the dataset and explore model performance by
                          slice.
                        </div>
                      </paper-dialog>
                    </div>
                    <div class="perf-sort-box">
                      <div>
                        <paper-icon-button
                          icon="unfold-more"
                          class="perf-button"
                          on-tap="expandAllPerformance"
                          alt="expand all slices"
                          title="Expand all slices"
                        >
                        </paper-icon-button>
                        <paper-icon-button
                          icon="unfold-less"
                          class="perf-button"
                          on-tap="collapseAllPerformance"
                          alt="collapse all slices"
                          title="Collapse all slices"
                        >
                        </paper-icon-button>
                      </div>
                      <paper-dropdown-menu
                        label="Sort by"
                        class="threshold-dropdown perf-table-sort-menu"
                      >
                        <paper-listbox
                          slot="dropdown-content"
                          selected="{{selectedFeatureSort}}"
                          attr-for-selected="name"
                        >
                          <template
                            is="dom-repeat"
                            items="[[getFeatureSortBy(modelType, multiClass)]]"
                          >
                            <paper-item name="[[item]]">[[item]]</paper-item>
                          </template>
                        </paper-listbox>
                      </paper-dropdown-menu>
                    </div>
                  </div>
                  <div class="perf-table-header">
                    <div class="perf-table-arrow"></div>
                    <div class="perf-table-val">Feature Value</div>
                    <div class="perf-table-count">Count</div>
                    <div class$="[[getPerfTableModelClass(numModels)]]">
                      Model
                    </div>
                    <div class="perf-table-acc">Accuracy</div>
                  </div>
                  <div class="perf-table-entries-holder">
                    <template
                      is="dom-repeat"
                      items="[[featureValueThresholds]]"
                      as="featureValueThreshold"
                    >
                      <div class="perf-table-entry">
                        <div
                          class$="[[getPerfTableRowClass(featureValueThreshold.opened)]]"
                          data-index$="[[index]]"
                        >
                          <div class="perf-table-arrow">
                            <paper-icon-button
                              class$="[[getExpandCollapsePerfIconClass(featureValueThreshold.opened)]]"
                              icon="arrow-drop-down"
                              on-tap="togglePerfRow"
                            ></paper-icon-button>
                          </div>
                          <div
                            class="perf-table-val perf-table-clickable perf-table-text-entry"
                            on-tap="togglePerfRow"
                          >
                            [[getPrintableValue_(featureValueThreshold)]]
                          </div>
                          <div
                            class="perf-table-count perf-table-num-entry perf-table-clickable perf-table-text-entry"
                            on-tap="togglePerfRow"
                          >
                            [[getMultiClassFeatureValueCount(inferenceStats_,
                            featureValueThreshold)]]
                          </div>
                          <div
                            class$="[[getPerfTableModelClass(numModels)]]"
                            on-tap="togglePerfRow"
                          >
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <div
                                class="perf-table-text-entry perf-table-clickable"
                              >
                                [[getModelName_(index)]]
                              </div>
                            </template>
                          </div>
                          <div
                            class="perf-table-acc perf-table-clickable"
                            on-tap="togglePerfRow"
                          >
                            <template
                              is="dom-repeat"
                              items="{{featureValueThreshold.threshold}}"
                            >
                              <div
                                class="perf-table-text-entry perf-table-num-entry"
                              >
                                [[getMultiClassAccuracyModelIndex(inferenceStats_,
                                index, featureValueThreshold)]]
                              </div>
                            </template>
                          </div>
                        </div>
                      </div>
                      <iron-collapse opened="{{featureValueThreshold.opened}}">
                        <div
                          class="perf-table-entry-expanded flex-row-reverse scroll-x"
                        >
                          <template
                            is="dom-if"
                            if="[[shouldShowFeaturePerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]"
                          >
                            <div class="perfs-holder">
                              <div class="perf-holder">
                                <div class="conf-text">Confusion matrix</div>
                                <template
                                  is="dom-repeat"
                                  items="[[inferenceStats_]]"
                                  as="inferenceStat"
                                >
                                  <tf-confusion-matrix
                                    counts="[[getMultiClassConfMatrix(inferenceStats_, index, featureValueThreshold)]]"
                                    label="[[getConfusionMatrixLabel(index, numModels)]]"
                                    background="[[getConfusionMatrixColor(index)]]"
                                    all-items="[[allConfMatrixLabels]]"
                                  >
                                  </tf-confusion-matrix>
                                </template>
                              </div>
                            </div>
                            <template
                              is="dom-repeat"
                              items="[[allConfMatrixLabels]]"
                              as="label"
                              index-as="labelInd"
                            >
                              <div class="perfs-holder">
                                <div class="perf-holder">
                                  <div class="perf-curve-text">
                                    ROC curve for [[getLabel(labelInd)]]
                                    <paper-icon-button
                                      icon="info-outline"
                                      class="info-icon threshold-info-icon no-padding"
                                      on-tap="openDialog"
                                    >
                                    </paper-icon-button>
                                    <paper-dialog
                                      class="dialog-text"
                                      horizontal-align="right"
                                      vertical-align="bottom"
                                    >
                                      <div class="dialog-title">
                                        ROC curve
                                      </div>
                                      <div>
                                        A receiver operating characteristic
                                        (ROC) curve plots the true positive rate
                                        (TPR) against the false positive rate
                                        (FPR) at various classification
                                        thresholds.
                                      </div>
                                      <div>
                                        For this multi-class classification
                                        problem, we plot one ROC curve for each
                                        class, at each time considering the
                                        class in question as the positive one
                                        and all the others as negatives (<i
                                          >i.e.</i
                                        >
                                        <i>binarized</i> versions of the
                                        problem).
                                      </div>
                                    </paper-dialog>
                                  </div>
                                  <div class="perf-curve-x-label">
                                    False positive rate
                                  </div>
                                  <div class="perf-curve-y-label">
                                    True positive rate
                                  </div>
                                  <vz-line-chart2
                                    id="[[getRocChartLabelId(labelInd, index)]]"
                                    x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                    y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                  >
                                  </vz-line-chart2>
                                </div>
                                <div class="perf-holder">
                                  <div class="perf-curve-text">
                                    PR curve for [[getLabel(labelInd)]]
                                    <paper-icon-button
                                      icon="info-outline"
                                      class="info-icon threshold-info-icon no-padding"
                                      on-tap="openDialog"
                                    >
                                    </paper-icon-button>
                                    <paper-dialog
                                      class="dialog-text"
                                      horizontal-align="right"
                                      vertical-align="bottom"
                                    >
                                      <div class="dialog-title">PR curve</div>
                                      <div>
                                        A precision-recall (PR) curve plots
                                        precision against recall at various
                                        classification thresholds.
                                      </div>
                                      <div>
                                        For this multi-class classification
                                        problem, we plot one PR curve for each
                                        class, at each time considering the
                                        class in question as the positive one
                                        and all the others as negatives (<i
                                          >i.e.</i
                                        >
                                        <i>binarized</i> versions of the
                                        problem).
                                      </div>
                                    </paper-dialog>
                                  </div>
                                  <div class="perf-curve-x-label">Recall</div>
                                  <div class="perf-curve-y-label">
                                    Precision
                                  </div>
                                  <vz-line-chart2
                                    id="[[getPrChartLabelId(labelInd, index)]]"
                                    x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                    y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                  >
                                  </vz-line-chart2>
                                </div>
                              </div>
                            </template>
                          </template>
                        </div>
                      </iron-collapse>
                    </template>
                    <template
                      is="dom-if"
                      if="[[shouldShowOverallThresholder_(selectedBreakdownFeature)]]"
                    >
                      <div class="perf-table-entry">
                        <div class="perf-table-row-expanded">
                          <div class="perf-table-arrow">
                            <paper-icon-button
                              icon="arrow-drop-down"
                              on-tap="togglePerfRow"
                              disabled
                            ></paper-icon-button>
                          </div>
                          <div class="perf-table-val perf-table-text-entry">
                            All datapoints
                          </div>
                          <div class="perf-table-count perf-table-num-entry">
                            [[getMultiClassFeatureValueCount(inferenceStats_)]]
                          </div>
                          <div class$="[[getPerfTableModelClass(numModels)]]">
                            <template
                              is="dom-repeat"
                              items="{{overallThresholds}}"
                            >
                              <div class="perf-table-text-entry">
                                [[getModelName_(index)]]
                              </div>
                            </template>
                          </div>
                          <div class="perf-table-acc">
                            <template
                              is="dom-repeat"
                              items="[[inferenceStats_]]"
                              as="inferenceStat"
                            >
                              <div
                                class="perf-table-text-entry perf-table-num-entry"
                              >
                                [[getMultiClassAccuracyModelIndex(inferenceStats_,
                                index)]]
                              </div>
                            </template>
                          </div>
                        </div>
                      </div>
                      <div
                        class="perf-table-entry-expanded flex-row-reverse scroll-x"
                      >
                        <template
                          is="dom-if"
                          if="[[shouldShowOverallPerfCharts_(selectedLabelFeature, selectedBreakdownFeature, inferences)]]"
                        >
                          <div class="perfs-holder">
                            <div class="perf-holder">
                              <div class="conf-text">Confusion matrix</div>
                              <template
                                is="dom-repeat"
                                items="[[inferenceStats_]]"
                                as="inferenceStat"
                              >
                                <tf-confusion-matrix
                                  counts="[[getMultiClassConfMatrix(inferenceStats_, index)]]"
                                  label="[[getConfusionMatrixLabel(index, numModels)]]"
                                  background="[[getConfusionMatrixColor(index)]]"
                                  all-items="[[allConfMatrixLabels]]"
                                >
                                </tf-confusion-matrix>
                              </template>
                            </div>
                          </div>
                          <template
                            is="dom-repeat"
                            items="[[allConfMatrixLabels]]"
                            as="label"
                            index-as="labelInd"
                          >
                            <div class="perfs-holder">
                              <div class="perf-holder">
                                <div class="perf-curve-text">
                                  ROC curve for [[getLabel(labelInd)]]
                                  <paper-icon-button
                                    icon="info-outline"
                                    class="info-icon threshold-info-icon no-padding"
                                    on-tap="openDialog"
                                  >
                                  </paper-icon-button>
                                  <paper-dialog
                                    class="dialog-text"
                                    horizontal-align="right"
                                    vertical-align="bottom"
                                  >
                                    <div class="dialog-title">ROC curve</div>
                                    <div>
                                      A receiver operating characteristic (ROC)
                                      curve plots the true positive rate (TPR)
                                      against the false positive rate (FPR) at
                                      various classification thresholds.
                                    </div>
                                    <div>
                                      For this multi-class classification
                                      problem, we plot one ROC curve for each
                                      class, at each time considering the class
                                      in question as the positive one and all
                                      the others as negatives (<i>i.e.</i>
                                      <i>binarized</i> versions of the problem).
                                    </div>
                                  </paper-dialog>
                                </div>
                                <div class="perf-curve-x-label">
                                  False positive rate
                                </div>
                                <div class="perf-curve-y-label">
                                  True positive rate
                                </div>
                                <vz-line-chart2
                                  id="[[getRocChartLabelId(label, '')]]"
                                  x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                  y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                >
                                </vz-line-chart2>
                              </div>
                              <div class="perf-holder">
                                <div class="perf-curve-text">
                                  PR curve for [[getLabel(labelInd)]]
                                  <paper-icon-button
                                    icon="info-outline"
                                    class="info-icon threshold-info-icon no-padding"
                                    on-tap="openDialog"
                                  >
                                  </paper-icon-button>
                                  <paper-dialog
                                    class="dialog-text"
                                    horizontal-align="right"
                                    vertical-align="bottom"
                                  >
                                    <div class="dialog-title">PR curve</div>
                                    <div>
                                      A precision-recall (PR) curve plots
                                      precision against recall at various
                                      classification thresholds.
                                    </div>
                                    <div>
                                      For this multi-class classification
                                      problem, we plot one PR curve for each
                                      class, at each time considering the class
                                      in question as the positive one and all
                                      the others as negatives (<i>i.e.</i>
                                      <i>binarized</i> versions of the problem).
                                    </div>
                                  </paper-dialog>
                                </div>
                                <div class="perf-curve-x-label">Recall</div>
                                <div class="perf-curve-y-label">Precision</div>
                                <vz-line-chart2
                                  id="[[getPrChartLabelId(label, '')]]"
                                  x-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                  y-axis-formatter="[[getSimpleAxisFormatter(axisPrecision)]]"
                                >
                                </vz-line-chart2>
                              </div>
                            </div>
                          </template>
                        </template>
                      </div>
                    </template>
                  </div>
                </template>
                <template is="dom-if" if="[[isRegression_(modelType)]]" restamp>
                  <div class="perf-table-title-row">
                    <div class="flex">
                      <div class="perf-table-title">
                        [[getNoThresholdPerfTableTitle(selectedBreakdownFeature,
                        selectedSecondBreakdownFeature,
                        featureValueThresholds)]]
                      </div>
                      <paper-icon-button
                        icon="info-outline"
                        class="info-icon performance-info-icon no-padding"
                        on-tap="openDialog"
                      >
                      </paper-icon-button>
                      <paper-dialog
                        class="dialog-text"
                        horizontal-align="auto"
                        vertical-align="auto"
                      >
                        <div class="dialog-title">
                          Regression Performance Table
                        </div>
                        <div>
                          Set the ground truth feature to explore model
                          performance.
                        </div>
                        <div>
                          Slice the dataset and explore model performance by
                          slice.
                        </div>
                      </paper-dialog>
                    </div>
                    <paper-dropdown-menu
                      label="Sort by"
                      class="threshold-dropdown perf-table-sort-menu"
                    >
                      <paper-listbox
                        slot="dropdown-content"
                        selected="{{selectedFeatureSort}}"
                        attr-for-selected="name"
                      >
                        <template
                          is="dom-repeat"
                          items="[[getFeatureSortBy(modelType, multiClass)]]"
                        >
                          <paper-item name="[[item]]">[[item]]</paper-item>
                        </template>
                      </paper-listbox>
                    </paper-dropdown-menu>
                  </div>
                  <div class="perf-table-header">
                    <div class="perf-table-arrow"></div>
                    <div class="perf-table-val">Feature Value</div>
                    <div class="perf-table-count">Count</div>
                    <div class="perf-table-error">Mean error</div>
                    <div class="perf-table-error">Median error</div>
                    <div class="perf-table-error">Mean absolute error</div>
                    <div class="perf-table-error">Median absolute error</div>
                    <div class="perf-table-sq-error">Mean squared error</div>
                    <div class="perf-table-sq-error">Median squared error</div>
                  </div>
                  <div class="perf-table-entries-holder">
                    <template is="dom-repeat" items="[[regressionEntries_]]">
                      <div class="perf-table-entry">
                        <div class="perf-table-row">
                          <div class="perf-table-arrow"></div>
                          <div class="perf-table-val perf-table-text-entry">
                            [[item.name]]
                          </div>
                          <div
                            class="perf-table-count perf-table-num-entry perf-table-text-entry"
                          >
                            [[item.count]]
                          </div>
                          <div
                            class="perf-table-error perf-table-num-entry perf-table-text-entry"
                          >
                            [[formatError(item.meanError)]]
                          </div>
                          <div
                            class="perf-table-error perf-table-num-entry perf-table-text-entry"
                          >
                            [[formatError(item.medianError)]]
                          </div>
                          <div
                            class="perf-table-error perf-table-num-entry perf-table-text-entry"
                          >
                            [[formatError(item.meanAbsError)]]
                          </div>
                          <div
                            class="perf-table-sq-error perf-table-num-entry perf-table-text-entry"
                          >
                            [[formatError(item.medianAbsError)]]
                          </div>
                          <div
                            class="perf-table-error perf-table-num-entry perf-table-text-entry"
                          >
                            [[formatError(item.meanSquaredError)]]
                          </div>
                          <div
                            class="perf-table-sq-error perf-table-num-entry perf-table-text-entry"
                          >
                            [[formatError(item.medianSquaredError)]]
                          </div>
                        </div>
                      </div>
                    </template>
                  </div>
                </template>
              </div>
            </div>
            <div class="stats-tab">
              <facets-overview
                id="overview"
                search-string="{{featureSearchValue}}"
              ></facets-overview>
            </div>
          </iron-pages>
        </div>
      </div>
    </div>
    <style include="dashboard-style"></style>
  </template>

  <script>
    const maxStringLengthToDecode = 100000;
    const inferenceLabelStr = ' Inference label';
    const inferenceValueStr = ' Inference value';
    const inferenceCorrectStr = ' Inference correct';
    const inferenceErrorStr = ' Inference error';
    const inferenceAbsErrorStr = ' Inference absolute error';
    const inferenceSquaredErrorStr = ' Inference squared error';
    const inferenceScoreStr = ' Inference score';
    const exampleIdKey = ' Datapoint ID';
    // requestDistanceWithCallback can be invoked with the callbacks in this
    // enum. Please add a function to this list if you want it to be invoked
    // at the end of custom distance computation.
    const distanceCallbacks = {
      finalizeClosestCounterfactual: 0,
      finalizeAddDistanceMetric: 1,
    };

    // Special feature names and feature name prefixes and suffixes for parsing
    // inference and attribution information from TFMA-generated input.
    const classificationResultsKey = 'predictions__probabilities';
    const regressionResultsKey = 'predictions';
    const attributionPrefix = 'attributions__';
    const featureForAttributionPrefix = 'features__';
    const attributionSparseKeySuffix = '_keys';
    const attributionSparseValueSuffix = '_values';

    // Colors for the attribution color scale.
    const posAttributionHighColor = '#3D7078';
    const posAttributionLowColor = '#6A9EA7';
    const neutralAttributionColor = '#FFD8C3';
    const negAttributionLowColor = '#C7696E';
    const negAttributionHighColor = '#943A43';
    const COLOR_INTERPOLATOR = d3.interpolateRgb;
    const LEGEND_WIDTH_PX = 160;
    const LEGEND_HEIGHT_PX = 8;

    function deleteElement(elt) {
      if (elt && elt.parentElement) {
        elt.parentElement.removeChild(elt);
      }
    }

    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }

    (function() {
      const PLUGIN_NAME = 'whatif';

      Polymer({
        is: 'tf-interactive-inference-dashboard',
        properties: {
          // TensorBoard plugin standard.
          _requestManager: {
            type: Object,
            value: () => new tf_backend.RequestManager(),
          },
          _canceller: {
            type: Object,
            value: () => new tf_backend.Canceller(),
          },

          // User-provided fields for WIT plugin from settings dialog.
          examplesPath: {
            type: String,
          },
          modelName: {
            type: String,
            observer: 'modelNameChanged_',
          },
          parsedModelNames: {
            type: String,
          },
          inferenceAddress: {
            type: String,
          },
          modelType: {
            type: String,
          },
          modelSignature: {
            type: String,
          },
          modelVersion: {
            type: String,
          },
          maxExamples: {
            type: Number,
          },
          labelVocabPath: {
            type: String,
          },
          maxInferenceEntriesPerRun: Number,
          // Number of buckets when aggregating numeric features.
          numPrimaryBuckets: {
            type: Number,
            value: 2,
            observer: 'breakdownFeatureSelected_',
          },
          numSecondaryBuckets: {
            type: Number,
            value: 2,
            observer: 'breakdownFeatureSelected_',
          },

          // Inferences from servo.
          inferences: {
            type: Object,
            observer: 'newInferences_',
            value: () => ({}),
          },
          // Extra outputs from inference. A dict with two fields: 'indices' and
          // 'extra'. Indices contains a list of example indices that
          // these new outputs apply to. Extra contains a list of extra output
          // objects, one for each model being inferred. The object for each
          // model is a dict of output data names to lists of the output values
          // for that data, one entry for each example that was inferred upon.
          // 'attributions' is one of these output data which is parsed into the
          // 'attributions' object defined below as a special case. Any other extra
          // data provided are displayed by WIT with each example.
          // @type {indices: Array<number>,
          //        extra: Array<{!Object<string, Array<number|string>>}>}
          extraOutputs: {
            type: Object,
            observer: 'newExtraOutputs_',
          },
          // Attributions from inference. A dict with two fields: 'indices' and
          // 'attributions'. Indices contains a list of example indices that
          // these new attributions apply to. Attributions contains a list of
          // attributions for each of those examples.
          // The attribution object for each example is a dict of feature name
          // to attribution value.
          // The attribution value is one of the following:
          // - A single number representing the attribution to that entire feature
          //   value.
          // - A list of numbers representing the attributions to individual
          //   values of a multivalent feature - such as pixels in an image or
          //   numbers in a list of numbers.
          // - A 2D list for sparse attributions of a multivalent feature. The
          //   first list contains the feature values for which attributions
          //   exist. The second list contains the numeric attributions for each
          //   of those feature values.
          attributions: {
            type: Object,
            value: {indices: [], attributions: []},
            observer: 'newAttributions_',
          },
          // Minimum attribution value seen in the data.
          minAttribution: {type: Number, value: 0},
          // Maximum attribution value seen in the data.
          maxAttribution: {type: Number, value: 0},
          // Color scale for attribution coloring.
          attributionColorScale: Object,
          // Examples and their inferences merged into a single list.
          // # Samples -> .inferences -> # Inferences -> # Models -> # Labels
          examplesAndInferences: {
            type: Array,
            value: () => [],
            observer: 'computeSelectedExampleAndInference',
          },
          // The currently selected item from the examplesAndInferences list,
          // selected through clicking in Facets Dive.
          /** @type {?Object} */
          selectedExampleAndInference: {
            type: Object,
          },
          // The closest counterfatual example to the currently selected item,
          // if one is found through the counterfactual button.
          /** @type {?Object} */
          counterfactualExampleAndInference: {
            type: Object,
          },
          // The examples list in the format to provide to Facets Dive.
          // Each element in the list represents a datapoint and is a dictionary
          // with keys being the features and values being the value of a feature,
          // or a list of values for those features that contain more than one
          // feature value.
          visdata: {
            type: Array,
            value: () => [],
          },
          // The selected items list provided by Facets Dive. The What-If Tool
          // only makes use of the first selected item, but Facets Dive itself
          // maintains a list of all selected items and this is bound to that
          // list provided by Facets Dive.
          selected: {
            type: Array,
            value: () => [],
            observer: 'computeSelectedExampleAndInference',
          },
          // The selected item to compare, provided to Facets Dive.
          comparedIndices: {
            type: Array,
            value: () => [],
          },
          // List of strings corresponding to inference numeric labels for
          // classification models, from file at labelVocabPath.
          labelVocab: {
            type: Array,
            value: () => [],
          },
          // True if an example has been updated.
          updatedExample: {
            type: Boolean,
            value: false,
          },
          imageFeatureName: {
            type: String,
            value: 'image/encoded',
            readonly: true,
          },
          // The dataset stats from Facets Dive to be used for the classification
          // threshold logic.
          stats: Object,
          // Feature to see performance breakdowns for the values of.
          selectedBreakdownFeature: {
            type: String,
            value: '',
            observer: 'breakdownFeatureSelected_',
          },
          // Second feature to see performance breakdowns for the values of,
          // crossed with the first selected feature.
          selectedSecondBreakdownFeature: {
            type: String,
            value: '',
            observer: 'breakdownFeatureSelected_',
          },
          // True if a custom distance function is set and is in use.
          customDistanceFunctionSet: {
            type: Boolean,
            value: false,
            observer: 'customDistanceFunctionSetChanged_',
          },
          // Feature for true label.
          selectedLabelFeature: {
            type: String,
            value: '',
            observer: 'labelFeatureSelected_',
          },
          // Choose which model is used for counterfactual computation
          nearestCounterfactualModelIndex: {
            type: Number,
            value: 0,
          },
          // Calculated statistics from the inference results.
          inferenceStats_: {
            type: Array,
            value: () => [],
          },
          // Array of feature values and their set classification thresholds, for
          // Polymer display purposes.
          featureValueThresholds: {
            type: Array,
            value: () => [],
            observer: 'featureValueThresholdsChanged_',
          },
          // A map of feature name to the featureValueThresholds indices, for quick
          // lookup.
          featureValueThresholdsIndexMap: Object,
          // The default inference label when the classification threshold isn't
          // met.
          defaultInferenceLabel: {
            type: Number,
            value: 0,
            observer: 'refreshInferences_',
          },
          // The classification threshold when it isn't being set on a
          // per-feature-value basis. One per model.
          overallThresholds: {
            type: Array,
            value: () => [],
          },
          // Which side-tab is selected.
          sideTabSelected: {
            type: Number,
            value: 0,
            observer: 'sideTabSelectedChanged_',
          },
          // Boolean for if running in "local" demo mode, meaning this isn't
          // part of a TensorBoard build and has no backend.
          local: {
            type: Boolean,
            value: false,
            observer: 'localChanged_',
          },
          // Atlas URL for "local" demo mode.
          localAtlasUrl: String,
          // List of features for which we can make partial dep plots.
          partialDepPlotEligibleFeatures: {
            type: Array,
            value: () => [], // [{name: 'a_numeric_feature', observedMin: -10,
            //   observedMax: 10},
            // {name: 'a_categorical_feature', samples: []}]
            observer: 'partialDepPlotEligibleFeaturesSet',
          },
          // Features that we are currently creating partial dep plots for.
          partialDepPlotPendingFeatures: {
            type: Array,
            value: () => [],
          },
          // Mode of how individual examples are display in the side panel.
          exampleDisplayMode: {
            type: String,
            value: 'stacked',
          },
          // Search string for feature searching.
          featureSearchValue: String,
          // Ratio of false positive to false negative for grading classification
          // thresholds.
          incorrectPredCostRatio: {
            type: Number,
            value: 1,
            observer: 'costRatioChanged_',
          },
          // If the classification model is a multi-class model.
          multiClass: {
            type: Boolean,
          },
          // If the examples loaded are SequenceExamples.
          sequenceExamples: {
            type: Boolean,
          },
          // Sampling odds (1: load all examples, .2: sample 20% of examples)
          samplingOdds: {
            type: Number,
          },
          // Whether to use the TF Serving Predict API or not.
          usePredictApi: {
            type: Boolean,
          },
          // Name of the output tensor to parse when using the Predict API.
          predictOutputTensor: {
            type: String,
          },
          // Name of the intput tensor to parse when using the Predict API.
          predictInputTensor: {
            type: String,
          },
          // Precision on charts for performance measuring.
          axisPrecision: {
            type: Number,
            value: 2,
          },
          // Stats calculated from the overview stats proto used for determining
          // counterfactual example distance.
          distanceStats_: {
            type: Object,
          },
          // Whether to show distance to selected example by L1 or L2 distance.
          facetDistSwitch: {
            type: String,
            value: 'L1',
          },
          // Facets Dive feature name for distance to the selected example.
          facetDistFeatureName: {
            type: String,
          },
          // All previously-created feature names for distances to selected
          // examples.
          facetDistFeatureNames: {
            type: Array,
            value: () => [],
          },
          // What Facets Dive setting to use to show distance to selected
          // example.
          facetDistSetting: {
            type: String,
            value: 'colorBy',
          },
          exampleStatusStr: {
            type: String,
            value: 'No datapoints loaded yet',
          },
          // The example ID number selected in the text input
          selectedExampleNum: {
            type: Number,
            value: '',
            observer: 'selectedExampleInputChanged_',
          },
          // The max ID number for a selected example.
          selectedExampleMax: Number,
          openedContextTools: {
            type: Boolean,
            value: true,
          },
          openedPerformance: {
            type: Boolean,
            value: true,
          },
          openedTrueLabel: {
            type: Boolean,
            value: true,
          },
          openedExplorer: {
            type: Boolean,
            value: true,
          },
          openedInferenceResults: {
            type: Boolean,
            value: true,
          },
          regressionEntries_: {
            type: Array,
          },
          nearestCounterfactualDist: {
            type: String,
            value: 'L1',
          },
          minCounterfactualValueDist: Number,
          maxCounterfactualValueDist: Number,
          visMode: {
            type: String,
            value: 'dive',
            observer: 'visModeChanged_',
          },
          // The optimization setting selected for setting classification
          // thresholds.
          optimizationSelected: {
            type: String,
            value: 'custom',
            observer: 'optimizationSelectedChanged_',
          },
          compareTitle: String,
          // Dictionary of features to feature value attributions for display
          // in the example viewer. Filled in if the selected example contains
          // attribution information.
          attribution: {
            type: Object,
            value: () => ({}),
          },
          // True if showing global PD plots. False if showing individual PD
          // plots.
          globalPdPlots: {
            type: Boolean,
            value: true,
          },
          // Number of models, only updated when user clicks "Accept" in settings
          // pane
          numModels: {
            type: Number,
            readOnly: true,
          },
          // Show nearest counterfactual toggle button setting.
          showNearestCounterfactual: {
            type: Boolean,
            value: false,
          },
          selectedFeatureSort: {
            type: String,
            value: 'Count',
            observer: 'selectedFeatureSortChanged_',
          },
          // Colors for lines and bars in partial dependence plots.
          pdPlotColors: {
            type: Array,
            value: () => [
              d3.color('rgb(31, 119, 180)'),
              d3.color('rgb(255, 127, 14)'),
              d3.color('rgb(44, 160, 44)'),
              d3.color('rgb(214, 39, 40)'),
              d3.color('rgb(148, 103, 189)'),
              d3.color('rgb(140, 86, 75)'),
              d3.color('rgb(227, 119, 194)'),
              d3.color('rgb(127, 127, 127)'),
              d3.color('rgb(188, 189, 34)'),
              d3.color('rgb(23, 190, 207)'),
            ],
          },
          // Transparent version of colors for partial dependence plots for
          // indicating classification threshold values.
          pdPlotTransparentColors: {
            type: Array,
            value: () => [
              d3.color('rgba(31, 119, 180, 0.3)'),
              d3.color('rgba(255, 127, 14, 0.3)'),
              d3.color('rgba(44, 160, 44, 0.3)'),
              d3.color('rgba(214, 39, 40, 0.3)'),
              d3.color('rgba(148, 103, 189, 0.3)'),
              d3.color('rgba(140, 86, 75, 0.3)'),
              d3.color('rgba(227, 119, 194, 0.3)'),
              d3.color('rgba(127, 127, 127, 0.3)'),
              d3.color('rgba(188, 189, 34, 0.3)'),
              d3.color('rgba(23, 190, 207, 0.3)'),
            ],
          },
          // Colors for lines in ROC curves
          rocCurveColors: {
            type: Array,
            value: () => [
              d3.color('rgb(18, 181, 206)'),
              d3.color('rgb(250, 120, 23)'),
            ],
          },
          rocCurveLineColors: {
            type: Array,
            value: () => [
              d3.color('rgba(18, 181, 206, 0.6)'),
              d3.color('rgba(250, 120, 23, 0.6)'),
            ],
          },
          // Colors for confusion matrix backgrounds.
          confMatrixColors: {
            type: Array,
            value: () => [
              d3.color('rgb(18, 181, 206)'),
              d3.color('rgb(250, 120, 23)'),
            ],
          },
          // Dictionary where keys contain all cell labels for confusion
          // matrices.
          allConfMatrixLabels: {
            type: Array,
            value: () => [],
          },
          // Controls if the loading spinner is hidden from view.
          spinnerHidden_: {
            type: Boolean,
            value: true,
          },
          isSortingEligibleFeatures: {
            type: Boolean,
            value: false,
          },
          // Sort order for features in the example viewer.
          exampleFeatureSortOrder: {
            type: String,
            value: 'attribution',
          },
          // This object maps each feature to a list of buckets delimiters,
          // used for aggregating numeric features.
          // For instance: `{'age': [10, 30, 60, 90]}` would mean values should
          // be bucketed into either `[10, 30)`, `[30, 60)` or `[60, 90]`.
          featureBucketEdges_: {
            type: Object,
            value: () => ({}),
          },
        },

        observers: [
          'setFacetDistFeatureName(facetDistSwitch, selected)',
          'nearestCounterfactualStatusChanged_(showNearestCounterfactual, nearestCounterfactualModelIndex, nearestCounterfactualDist, minCounterfactualValueDist)',
        ],

        // Required function.
        reload: function() {},

        openDialog: function(event) {
          event.stopPropagation();
          const dialog = event.target.parentElement.querySelector(
            'paper-dialog'
          );
          dialog.open();
        },

        ready: function() {
          const side = d3.select(this.$.side);
          const center = d3.select(this.$.center);
          const resizer = this.$.resizer;
          const self = this;

          const dragResize = d3.drag().on('drag', () => {
            // Determine resizer position relative to width of the tool.
            const x = d3.mouse(resizer.parentNode.parentNode)[0];
            const width = resizer.parentNode.parentNode.offsetWidth;
            let perc = (x / width) * 100;

            // Side panel will be a minimum of 20% width.
            perc = Math.max(perc, 20);

            center.style('width', 100 - perc + '%');
            side.style('width', perc + '%');

            // Force the Dive visualization to recompute item positions and handle
            // changed container size.
            self.$.dive.$.vis._updateGridFaceting();
            self.$.dive.$.vis._onIronResize();
          });

          d3.select(resizer).call(dragResize);
        },

        attached: function() {
          // Check if the plugin was created
          this._requestManager
            .request(tf_backend.getRouter().pluginsListing())
            .then((plugins) => {
              if (!(PLUGIN_NAME in plugins)) {
                // The plugin was not created
                this.$.inferencesettings.close();
                this.$.initialDialog.openNoTensorFlowDialog();
              } else {
                // The plugin was created
                this.$.initialDialog.closeDialog();
              }
            });
        },

        settingsClicked_: function() {
          this.$.inferencesettings.toggle();
        },

        localChanged_: function() {
          if (this.local) {
            this.closeSettings_();
          }
        },

        modelNameChanged_: function() {
          this.parsedModelNames = this.modelName
            .split(',')
            .map((str) => str.trim());
          // If any names are identical, then add an index-based postfix
          // to make them unique, for display purposes.
          for (let i = 0; i < this.parsedModelNames.length; i++) {
            const currentName = this.parsedModelNames[i];
            for (let j = i + 1; j < this.parsedModelNames.length; j++) {
              if (this.parsedModelNames[j] == currentName) {
                this.parsedModelNames[i] = currentName + ' ' + (i + 1);
                this.parsedModelNames[j] = currentName + ' ' + (j + 1);
              }
            }
          }
        },

        closeSettings_: function() {
          this.$.inferencesettings.close();
        },

        showDistanceClicked_: function() {
          this.$.distancedialog.toggle();
        },
        customDistanceFunctionSetChanged_: function() {
          if (this.customDistanceFunctionSet) {
            this.nearestCounterfactualDist = 'Custom';
            this.facetDistSwitch = 'Custom';
          } else {
            this.nearestCounterfactualDist = 'L1';
            this.facetDistSwitch = 'L1';
          }
        },

        requestAddDistanceMetric: function() {
          const selected = this.selected[0];
          const params = {
            callbackParams: {featureName: this.facetDistFeatureName},
            distanceParams: {},
          };
          // Custom distance function can only be used when local.
          // If using custom distance function, request distances and return.
          if (this.local && this.customDistanceFunctionSet) {
            this.requestDistanceWithCallback(
              selected,
              distanceCallbacks.finalizeAddDistanceMetric,
              params
            );
            return;
          } else {
            const dists = [];
            const useL2Distance = this.facetDistSwitch == 'L2';
            for (let i = 0; i < this.visdata.length; i++) {
              dists.push(
                this.getDist(
                  this.visdata[selected],
                  this.visdata[i],
                  useL2Distance
                )
              );
            }
            this.finalizeAddDistanceMetric(
              selected,
              dists,
              params.callbackParams
            );
          }
        },

        invokeCustomDistanceCallback: function(callbackObj) {
          switch (callbackObj.funId) {
            case distanceCallbacks.finalizeClosestCounterfactual:
              this.finalizeClosestCounterfactual(
                callbackObj.exInd,
                callbackObj.distances,
                callbackObj.params
              );
              break;
            case distanceCallbacks.finalizeAddDistanceMetric:
              this.finalizeAddDistanceMetric(
                callbackObj.exInd,
                callbackObj.distances,
                callbackObj.params
              );
              break;
          }
        },

        finalizeAddDistanceMetric: function(exInd, distances, callbackParams) {
          const facetDistFeatureName = callbackParams.featureName;
          this.facetDistFeatureNames.push(facetDistFeatureName);
          for (let i = 0; i < this.visdata.length; i++) {
            this.visdata[i][facetDistFeatureName] = distances[i];
          }
          this.refreshDive_();
          if (this.facetDistSetting == 'colorBy') {
            this.$.dive.colorBy = facetDistFeatureName;
          } else if (this.facetDistSetting == 'verticalFacet') {
            this.$.dive.verticalFacet = facetDistFeatureName;
          } else if (this.facetDistSetting == 'horizontalFacet') {
            this.$.dive.horizontalFacet = facetDistFeatureName;
          } else if (this.facetDistSetting == 'verticalPosition') {
            this.$.dive.verticalPosition = facetDistFeatureName;
          } else if (this.facetDistSetting == 'horizontalPosition') {
            this.$.dive.horizontalPosition = facetDistFeatureName;
          }
        },

        setFacetDistFeatureName: function(facetDistSwitch, selected) {
          this.facetDistFeatureName =
            ' ' + facetDistSwitch + ' distance to datapoint ' + selected[0];
        },

        nearestCounterfactualStatusChanged_: function(show) {
          if (show) {
            this.findClosestCounterfactual_();
          } else {
            this.comparedIndices = [];
            this.counterfactualExampleAndInference = null;
            this.refreshSelectedDatapoint_();
          }
        },

        refreshSelectedDatapoint_: function() {
          const temp = this.selectedExampleAndInference;
          this.selectedExampleAndInference = null;
          this.selectedExampleAndInference = temp;
        },

        isSameInferenceClass_: function(val1, val2) {
          return this.isRegression_(this.modelType)
            ? Math.abs(val1 - val2) < this.minCounterfactualValueDist
            : val1 === val2;
        },

        adjustMaxCounterfactualValueDist_: function(selected, valueName) {
          this.maxCounterfactualValueDist = Math.max(
            this.stats[valueName].numberMax - this.visdata[selected][valueName],
            this.visdata[selected][valueName] - this.stats[valueName].numberMin
          );
        },

        adjustMinCounterfactualValueDist_: function() {
          const valueName = this.strWithModelName_(
            inferenceValueStr,
            this.nearestCounterfactualModelIndex
          );
          this.minCounterfactualValueDist = this.distanceStats_[
            valueName
          ].stdDev;
        },

        finalizeClosestCounterfactual: function(exInd, distances) {
          // Distances are indexed by example ids
          const modelInferenceValueStr = this.strWithModelName_(
            inferenceValueStr,
            this.nearestCounterfactualModelIndex
          );
          if (this.isRegression_(this.modelType)) {
            this.adjustMaxCounterfactualValueDist_(
              exInd,
              modelInferenceValueStr
            );
          }
          let closestDist = Number.POSITIVE_INFINITY;
          let closest = -1;
          for (let i = 0; i < this.visdata.length; i++) {
            // Skip the selected example itself and examples with the same inference class.
            if (
              i === exInd ||
              this.isSameInferenceClass_(
                this.visdata[exInd][modelInferenceValueStr],
                this.visdata[i][modelInferenceValueStr]
              )
            ) {
              continue;
            }
            let dist = distances[i];
            if (dist < closestDist) {
              closestDist = dist;
              closest = i;
            }
          }
          if (closest != -1) {
            // Display the counterfactual in dive and example viewer.
            this.comparedIndices = [closest];
            this.counterfactualExampleAndInference = this.examplesAndInferences[
              closest
            ];
            this.compareTitle = 'Counterfactual value(s)';
          }
        },

        findClosestCounterfactual_: function() {
          const selected = this.selected[0];
          // Custom distance function can only be used when local.
          // If using custom distance function, request distances and return.
          if (this.local && this.customDistanceFunctionSet) {
            this.requestDistanceWithCallback(
              selected,
              distanceCallbacks.finalizeClosestCounterfactual,
              {callbackParams: {}, distanceParams: {}}
            );
            return;
          }

          const modelInferenceValueStr = this.strWithModelName_(
            inferenceValueStr,
            this.nearestCounterfactualModelIndex
          );
          if (this.isRegression_(this.modelType)) {
            this.adjustMaxCounterfactualValueDist_(
              selected,
              modelInferenceValueStr
            );
          }
          let closestDist = Number.POSITIVE_INFINITY;
          let closest = -1;
          for (let i = 0; i < this.visdata.length; i++) {
            // Skip the selected example itself and examples with the same inference class.
            if (
              i === selected ||
              this.isSameInferenceClass_(
                this.visdata[selected][modelInferenceValueStr],
                this.visdata[i][modelInferenceValueStr]
              )
            ) {
              continue;
            }
            let dist = this.getDist(
              this.visdata[selected],
              this.visdata[i],
              this.nearestCounterfactualDist == 'L2'
            );
            if (dist < closestDist) {
              closestDist = dist;
              closest = i;
            }
          }
          if (closest != -1) {
            // Display the counterfactual in dive and example viewer.
            this.comparedIndices = [closest];
            this.counterfactualExampleAndInference = this.examplesAndInferences[
              closest
            ];
            this.compareTitle = 'Counterfactual value(s)';
          }
        },

        // Call backend for distance computation, backend calls callback function
        // with computed distances and parameters
        // TODO (tolgab) If TensorBoard supports custom distance functions
        // add ability to call into their backend as well (non-local mode).
        requestDistanceWithCallback: function(exInd, callbackFun, params) {
          const urlParams = {
            index: exInd,
            callback: callbackFun,
            params: params,
          };
          this.fire('compute-custom-distance', urlParams);
        },

        /**
         * Gets distance between two examples using L1 or L2 distance.
         */
        getDist: function(a, b, useL2Distance) {
          let dist = 0;
          const allKeys = [...new Set([...Object.keys(a), ...Object.keys(b)])];
          for (let featIndex = 0; featIndex < allKeys.length; featIndex++) {
            const feat = allKeys[featIndex];
            // Skip inferred keys, label feature and features with only unique
            // values.
            if (
              this.isComputedKeyStr_(feat) ||
              feat == this.selectedLabelFeature ||
              this.stats[feat].uniqueCount == this.examplesAndInferences.length
            ) {
              continue;
            }
            let aVals = a[feat];
            let bVals = b[feat];
            if (!Array.isArray(aVals)) {
              aVals = [aVals];
            }
            if (!Array.isArray(bVals)) {
              bVals = [bVals];
            }
            const maxLength = Math.max(aVals.length, bVals.length);
            let featureTotalDist = 0;
            for (let i = 0; i < maxLength; i++) {
              if (this.distanceStats_[feat].isNumeric) {
                featureTotalDist += this.getNumericDist(
                  aVals[i],
                  bVals[i],
                  this.distanceStats_[feat]
                );
              } else {
                featureTotalDist += this.getCategoricalDist(
                  aVals[i],
                  bVals[i],
                  this.distanceStats_[feat]
                );
              }
            }
            let newDist = featureTotalDist / maxLength;
            if (useL2Distance) {
              newDist *= newDist;
            }
            dist += newDist;
          }
          return dist;
        },

        /** Gets distance between two numeric feature values. */
        getNumericDist: function(a, b, stats) {
          if (a == null || b == null) {
            return 1;
          }
          if (!stats.stdDev) {
            return 0;
          }
          // Return the difference divided by the standard deviation of that
          // feature across all examples.
          return Math.abs((a - b) / stats.stdDev);
        },

        /** Gets distance between two categorical feature values. */
        getCategoricalDist: function(a, b, stats) {
          if (a == null || b == null) {
            return 1;
          }
          if (a == b) {
            return 0;
          }
          // If they are different return the probability that any two examples
          // have the same feature value for this feature.
          return stats.probSameValue;
        },

        visModeChanged_: function(mode) {
          mode == 'dive'
            ? this.hidePartialDependencePlots_()
            : this.showPartialDependencePlots_();
        },

        hidePartialDependencePlots_: function() {
          this.$.partialplotholder.style.display = 'none';
        },

        showPartialDependencePlots_: function() {
          this.$.partialplotholder.style.display = 'flex';
          requestAnimationFrame(() => this.populatePdTabs());
        },

        areTherePdPlotFeatures_: function(partialDepPlotEligibleFeatures) {
          return (
            partialDepPlotEligibleFeatures &&
            partialDepPlotEligibleFeatures.length > 0
          );
        },

        selectedIndicesChanged_: function(event) {
          this.selected = event.detail.value;
          this.setAttributions();
          this.selectedDataUpdated_();
          if (this.showNearestCounterfactual && this.selected.length != 0) {
            this.findClosestCounterfactual_();
          } else {
            this.comparedIndices = [];
          }
        },

        selectNextDatapoint_: function() {
          const id = (this.selected[0] + 1) % this.visdata.length;
          this.$.dive.selectedIndices = [id];
        },

        selectPrevDatapoint_: function() {
          const id =
            (((this.selected[0] - 1) % this.visdata.length) +
              this.visdata.length) %
            this.visdata.length;
          this.$.dive.selectedIndices = [id];
        },

        selectedExampleInputChanged_: function(newDatapoint) {
          if (newDatapoint == null || newDatapoint == '') {
            return;
          }
          const id = +newDatapoint;
          if (isNaN(id) || id < 0 || id >= this.visdata.length) {
            return;
          }
          this.$.dive.selectedIndices = [id];
        },

        setExampleCollapsed_: function() {
          this.exampleDisplayMode = 'grid';
          this.$$('#viewer').expandedFeatures = {};
          this.$$('#viewer').expandAllFeatures = false;
          this.$$('#viewer').refreshExampleViewer();
        },

        setExampleShow_: function() {
          this.exampleDisplayMode = 'grid';
          this.$$('#viewer').expandAllFeatures = true;
        },

        setExampleExpanded_: function() {
          this.exampleDisplayMode = 'stacked';
          this.$$('#viewer').expandAllFeatures = true;
        },

        statsChanged_: function(event) {
          this.stats = event.detail.value;
        },

        isBinaryClassification_: function(modelType, multiClass) {
          return modelType == 'classification' && !multiClass;
        },

        isMultiClass_: function(modelType, multiClass) {
          return modelType == 'classification' && multiClass;
        },

        isRegression_: function(modelType) {
          return modelType == 'regression';
        },

        shouldShowFeatureDropdown_: function(stats) {
          return stats && Object.keys(stats).length > 0;
        },

        shouldShowSecondFeatureDropdown_: function(selectedBreakdownFeature) {
          return selectedBreakdownFeature != '';
        },

        shouldShowLabelDropdown_: function(stats) {
          return stats && Object.keys(stats).length > 0;
        },

        shouldHideCounterfactualModelSelector_: function(modelNames) {
          return !(modelNames && modelNames.length > 1);
        },

        shouldShowOverallPerfCharts_: function(
          selectedLabelFeature,
          selectedBreakdownFeature,
          inferences
        ) {
          return (
            selectedLabelFeature != '' &&
            selectedBreakdownFeature == '' &&
            inferences != null
          );
        },

        shouldShowFeaturePerfCharts_: function(
          selectedLabelFeature,
          selectedBreakdownFeature,
          inferences
        ) {
          return (
            selectedLabelFeature != '' &&
            selectedBreakdownFeature != '' &&
            inferences != null
          );
        },

        shouldShowCostRatio_: function(
          selectedLabelFeature,
          modelType,
          multiClass
        ) {
          return (
            selectedLabelFeature != '' &&
            this.isBinaryClassification_(modelType, multiClass)
          );
        },

        arePartialDependencePlotsEnabled_: function(
          selectedExampleAndInference,
          modelName,
          inferenceAddress
        ) {
          return (
            this.hasSelected(selectedExampleAndInference) &&
            this.areExamplesEditable_(modelName, inferenceAddress)
          );
        },

        hasSelected: function(selectedExampleAndInference) {
          return selectedExampleAndInference != null;
        },

        getFeatureList_: function(stats) {
          // Do not also threshold settings by the results of the inference as
          // they aren't real data features.
          const features = Object.keys(stats)
            .filter((feature) => !this.isComputedKeyStr_(feature))
            .sort();
          // Add a blank feature to be used for clearing the selected feature.
          features.push('');
          return features;
        },

        strStartsWith_: function(inStr, prefixStr) {
          return inStr.lastIndexOf(prefixStr, 0) == 0;
        },

        getModelName_: function(modelNumber) {
          return this.parsedModelNames[modelNumber];
        },

        strWithModelName_: function(inStr, modelNumber) {
          if (this.numModels > 1) {
            return inStr + ' ' + this.getModelName_(modelNumber);
          } else {
            return inStr;
          }
        },

        updateNumberOfModels: function() {
          this._setNumModels(this.modelName.split(',').length);
          // Initialize default overall thresholds
          this.selectedLabelFeature = '';
          this.selectedBreakdownFeature = '';
          this.selectedSecondBreakdownFeature = '';
          const overallThresholds = [];
          for (let modelInd = 0; modelInd < this.numModels; modelInd++) {
            overallThresholds.push({threshold: 0.5});
          }
          this.set('overallThresholds', overallThresholds);

          // If inference can be performed automatically at this point, due to
          // examples already being set, and now the model being set, then
          // cause inference to run.
          if (
            !this.shouldDisableInferButton_(
              this.examplesAndInferences,
              this.modelName,
              this.inferenceAddress,
              this.updatedExample
            )
          ) {
            this.inferClicked_();
          }
        },

        isComputedKeyStr_: function(feature) {
          return (
            this.strStartsWith_(feature, inferenceValueStr) ||
            this.strStartsWith_(feature, inferenceLabelStr) ||
            this.strStartsWith_(feature, inferenceCorrectStr) ||
            this.strStartsWith_(feature, inferenceErrorStr) ||
            this.strStartsWith_(feature, inferenceScoreStr) ||
            this.strStartsWith_(feature, inferenceAbsErrorStr) ||
            this.strStartsWith_(feature, inferenceSquaredErrorStr) ||
            feature == exampleIdKey ||
            this.facetDistFeatureNames.indexOf(feature) != -1
          );
        },

        /**
         * Get the key to which this example belongs when the dataset is sliced by the given feature(s).
         */
        getSliceKey_: function(example, feature1, feature2) {
          const bucketEdges = this.featureBucketEdges_;
          function maybeAggregate(feature) {
            if (feature && example[feature] === undefined) {
              return '?';
            }
            const edges = bucketEdges[feature];
            if (edges) {
              for (let i = 1; i < edges.length; i++) {
                if (
                  example[feature] < edges[i] ||
                  (example[feature] === edges[i] && i === edges.length - 1)
                ) {
                  const right = i < edges.length - 1 ? ')' : ']';
                  return '[' + edges[i - 1] + ', ' + edges[i] + right;
                }
              }
            }
            return example[feature];
          }
          return this.createCombinedValueString_(
            maybeAggregate(feature1),
            maybeAggregate(feature2)
          );
        },

        /**
         * Creates a list of all feature values of the selected breakdown feature
         * or feature crosses if two breakdown features are selected, and gets
         * inference stats per breakdown.
         */
        breakdownFeatureSelected_: function() {
          // When features to slice by change, set optimization strategy
          // back to custom (default).
          this.resetOptimizationSelected_();
          if (this.selectedBreakdownFeature == '') {
            this.selectedSecondBreakdownFeature = '';
          }
          this.calculateBucketEdges_(
            this.selectedBreakdownFeature,
            this.numPrimaryBuckets
          );
          this.calculateBucketEdges_(
            this.selectedSecondBreakdownFeature,
            this.numSecondaryBuckets
          );

          const thresholds = [];
          const thresholdsIndexMap = {};
          this.visdata.forEach((item) => {
            const key1 = this.getSliceKey_(item, this.selectedBreakdownFeature);
            const key2 = this.getSliceKey_(
              item,
              this.selectedSecondBreakdownFeature
            );
            const key = this.createCombinedValueString_(key1, key2);
            if (!(key in thresholdsIndexMap)) {
              thresholds.push({
                value: key1,
                value2: key2,
                threshold: deepClone(this.overallThresholds),
                opened: false,
              });
              thresholdsIndexMap[key] = thresholds.length - 1;
            }
          });
          this.set('featureValueThresholds', thresholds);
          this.refreshInferences_(false);
        },

        featureValueThresholdsChanged_: function(featureValueThresholds) {
          const map = {};
          for (let i = 0; i < featureValueThresholds.length; i++) {
            const key = this.createCombinedValueString_(
              featureValueThresholds[i].value,
              featureValueThresholds[i].value2
            );
            map[key] = i;
          }
          this.featureValueThresholdsIndexMap = map;
        },

        labelFeatureSelected_: function(feature) {
          // When the true label feature is selected, update inference stats.
          requestAnimationFrame(() => {
            this.updateInferenceStats_(true);
            this.refreshDive_();
          });
        },

        sideTabSelectedChanged_: function(tab) {
          if (tab == 1) {
            requestAnimationFrame(() => {
              this.updateInferenceStats_(true);
            });
          } else if (tab == 2) {
            // Force redraw of facets overview tables to ensure proper sizing.
            const tables = this.$.overview.querySelectorAll(
              'facets-overview-table'
            );
            for (let i = 0; i < tables.length; i++) {
              tables[i]._handleResize();
            }
          }
        },

        /**
         * Updates inference statistics, including breakdown stats if breakdown
         * features are selected, and updates visuals for those performance
         * stats.
         */
        updateInferenceStats_: function(regenInferenceStats) {
          // In the case user changes the number of models without refreshing
          // the page:
          // - The code may enter updateInferenceStats before
          // examplesAndInferences is updated for the correct number of models
          // - This may get called without regenInferenceStats, but
          // inferenceStats still contains the results for the old number of
          // models
          if (
            !this.inferenceStats_ ||
            !this.visdata ||
            this.selectedLabelFeature == '' ||
            this.examplesAndInferences.length == 0 ||
            this.examplesAndInferences[0].inferences == null ||
            this.examplesAndInferences[0].inferences[0].length !=
              this.numModels ||
            (this.inferenceStats_.length != this.numModels &&
              !regenInferenceStats)
          ) {
            return;
          }
          if (regenInferenceStats) {
            const inferenceStatsArray = [];
            let regressionEntries = [];
            for (let modelInd = 0; modelInd < this.numModels; modelInd++) {
              let inferenceStats = {};
              if (
                this.isBinaryClassification_(this.modelType, this.multiClass)
              ) {
                // For binary classifiers, update the confusion matrices values
                // for all possible classification thresholds.
                inferenceStats.thresholds = [];
                for (let i = 0; i < 101; i++) {
                  inferenceStats.thresholds.push({TP: 0, FP: 0, FN: 0, TN: 0});
                }
                inferenceStats.faceted = {};
                for (let i = 0; i < this.examplesAndInferences.length; i++) {
                  const item = this.visdata[i];
                  let facetedStats = null;
                  if (this.selectedBreakdownFeature != '') {
                    const facetKey = this.getSliceKey_(
                      item,
                      this.selectedBreakdownFeature,
                      this.selectedSecondBreakdownFeature
                    );
                    facetedStats = inferenceStats.faceted[facetKey];
                    if (!facetedStats) {
                      inferenceStats.faceted[facetKey] = [];
                      for (let i = 0; i < 101; i++) {
                        inferenceStats.faceted[facetKey].push({
                          TP: 0,
                          FP: 0,
                          FN: 0,
                          TN: 0,
                        });
                      }
                      facetedStats = inferenceStats.faceted[facetKey];
                    }
                  }
                  const nonZeroClassification = this.getClassificationBestNonZero(
                    i,
                    modelInd
                  );
                  let thresh = 0;
                  for (; thresh <= 100; thresh++) {
                    if (thresh > nonZeroClassification.score * 100) {
                      break;
                    }
                    if (
                      +item[this.selectedLabelFeature] ==
                      +nonZeroClassification.label
                    ) {
                      inferenceStats.thresholds[thresh]['TP'] += 1;
                      if (facetedStats) {
                        facetedStats[thresh]['TP'] += 1;
                      }
                    } else {
                      inferenceStats.thresholds[thresh]['FP'] += 1;
                      if (facetedStats) {
                        facetedStats[thresh]['FP'] += 1;
                      }
                    }
                  }
                  for (; thresh <= 100; thresh++) {
                    if (
                      item[this.selectedLabelFeature] == null ||
                      +item[this.selectedLabelFeature] == 0
                    ) {
                      inferenceStats.thresholds[thresh]['TN'] += 1;
                      if (facetedStats) {
                        facetedStats[thresh]['TN'] += 1;
                      }
                    } else {
                      inferenceStats.thresholds[thresh]['FN'] += 1;
                      if (facetedStats) {
                        facetedStats[thresh]['FN'] += 1;
                      }
                    }
                  }
                }
                // For binary classification, no need to specify all possible
                // labels for the confusion matrices as the data contains both
                // classes.
                this.allConfMatrixLabels = [];

                this.calcThresholdStats(inferenceStats.thresholds);
                for (let key in inferenceStats.faceted) {
                  if (inferenceStats.faceted.hasOwnProperty(key)) {
                    this.calcThresholdStats(inferenceStats.faceted[key]);
                  }
                }
              } else if (this.isMultiClass_(this.modelType, this.multiClass)) {
                // For multi-class classifiers, update the confusion matrices.
                inferenceStats.results = {};
                inferenceStats.faceted = {};
                const allLabels = new Set();
                for (let i = 0; i < this.examplesAndInferences.length; i++) {
                  const item = this.visdata[i];
                  let facetedStats = null;
                  if (this.selectedBreakdownFeature != '') {
                    const facetKey = this.getSliceKey_(
                      item,
                      this.selectedBreakdownFeature,
                      this.selectedSecondBreakdownFeature
                    );
                    facetedStats = inferenceStats.faceted[facetKey];
                    if (!facetedStats) {
                      inferenceStats.faceted[facetKey] = {};
                      facetedStats = inferenceStats.faceted[facetKey];
                    }
                  }
                  let statsActual =
                    inferenceStats.results[item[this.selectedLabelFeature]];
                  if (!statsActual) {
                    inferenceStats.results[
                      item[this.selectedLabelFeature]
                    ] = {};
                    statsActual =
                      inferenceStats.results[item[this.selectedLabelFeature]];
                  }
                  const modelInferenceValueStr = this.strWithModelName_(
                    inferenceValueStr,
                    modelInd
                  );
                  let count = statsActual[item[modelInferenceValueStr]];
                  allLabels.add(String(item[modelInferenceValueStr]));
                  allLabels.add(String(item[this.selectedLabelFeature]));
                  if (count == null) {
                    statsActual[item[modelInferenceValueStr]] = 1;
                  } else {
                    statsActual[item[modelInferenceValueStr]] += 1;
                  }
                  if (facetedStats) {
                    let statsActual =
                      facetedStats[item[this.selectedLabelFeature]];
                    if (!statsActual) {
                      facetedStats[item[this.selectedLabelFeature]] = {};
                      statsActual =
                        facetedStats[item[this.selectedLabelFeature]];
                    }
                    let count = statsActual[item[modelInferenceValueStr]];
                    if (count == null) {
                      statsActual[item[modelInferenceValueStr]] = 1;
                    } else {
                      statsActual[item[modelInferenceValueStr]] += 1;
                    }
                  }
                }
                this.allConfMatrixLabels = Array.from(allLabels.values());
                // Compute confusion data for perf curves
                const thresholds = {};
                for (let i = 0; i < this.examplesAndInferences.length; i++) {
                  const item = this.examplesAndInferences[i];
                  const trueLabel = this.visdata[i][
                    this.selectedLabelFeature
                  ].toString();
                  const scores =
                    item.inferences[item.inferences.length - 1][modelInd];
                  const slice =
                    this.selectedBreakdownFeature != ''
                      ? this.getSliceKey_(
                          this.visdata[i],
                          this.selectedBreakdownFeature,
                          this.selectedSecondBreakdownFeature
                        )
                      : '';
                  if (!(slice in thresholds)) {
                    thresholds[slice] = {};
                  }
                  for (let k = 0; k < scores.length; k++) {
                    const label = scores[k].label;
                    if (!(label in thresholds[slice])) {
                      thresholds[slice][label] = [];
                      for (let thresh = 0; thresh <= 100; thresh++) {
                        thresholds[slice][label].push({
                          TP: 0,
                          FP: 0,
                          FN: 0,
                          TN: 0,
                        });
                      }
                    }
                    const score = scores[k].score * 100;
                    let result = '';
                    for (let thresh = 0; thresh <= 100; thresh++) {
                      if (label === trueLabel) {
                        result = score > thresh ? 'TP' : 'FN';
                      } else {
                        result = score > thresh ? 'FP' : 'TN';
                      }
                      thresholds[slice][label][thresh][result] += 1;
                    }
                  }
                }
                Object.values(thresholds).forEach((t) =>
                  Object.values(t).forEach(this.calcThresholdStats)
                );
                inferenceStats.allThresholds = thresholds;
              } else {
                // For regression models, calculate inference error.
                inferenceStats.results = {errors: []};
                inferenceStats.faceted = {};
                for (let i = 0; i < this.examplesAndInferences.length; i++) {
                  const item = this.visdata[i];
                  let facetedStats = null;
                  if (this.selectedBreakdownFeature != '') {
                    const facetKey = this.getSliceKey_(
                      item,
                      this.selectedBreakdownFeature,
                      this.selectedSecondBreakdownFeature
                    );
                    facetedStats = inferenceStats.faceted[facetKey];
                    if (!facetedStats) {
                      inferenceStats.faceted[facetKey] = {errors: []};
                      facetedStats = inferenceStats.faceted[facetKey];
                    }
                  }
                  const inferenceError =
                    item[this.strWithModelName_(inferenceValueStr, modelInd)] -
                    item[this.selectedLabelFeature];
                  inferenceStats.results.errors.push(inferenceError);
                  if (facetedStats) {
                    facetedStats.errors.push(inferenceError);
                  }
                }
                regressionEntries.push(
                  this.fillInRegressionStats(
                    inferenceStats.results,
                    this.formatChartKey(
                      'All datapoints',
                      modelInd,
                      this.numModels
                    )
                  )
                );
                for (let key in inferenceStats.faceted) {
                  regressionEntries.push(
                    this.fillInRegressionStats(
                      inferenceStats.faceted[key],
                      this.formatChartKey(key, modelInd, this.numModels)
                    )
                  );
                }
              }
              inferenceStatsArray.push(inferenceStats);
            }
            regressionEntries = this.sortRegressionEntries(regressionEntries);
            this.regressionEntries_ = [];
            this.regressionEntries_ = regressionEntries;
            this.inferenceStats_ = inferenceStatsArray;
          }

          // Assigning to tempArray to force polymer to update the array.
          // Polymer does not recognize updates to elements within the array
          const tempArray = this.featureValueThresholds;
          this.featureValueThresholds = [];
          this.featureValueThresholds = this.sortFeatureValues(tempArray);

          // ROC and PR curves for the binary case
          if (this.isBinaryClassification_(this.modelType, this.multiClass)) {
            for (let i = 0; i < this.featureValueThresholds.length; i++) {
              const plotStats = [];
              const plotThresholds = [];
              const modelThresholds = this.featureValueThresholds[i].threshold;
              for (
                let modelInd = 0;
                modelInd < modelThresholds.length;
                modelInd++
              ) {
                const inferenceStats = this.inferenceStats_[modelInd];
                const key = this.createCombinedValueString_(
                  this.featureValueThresholds[i].value,
                  this.featureValueThresholds[i].value2
                );
                plotStats.push(inferenceStats.faceted[key]);
                plotThresholds.push(modelThresholds[modelInd].threshold);
              }
              this.plotChart(
                this.$$('#' + this.getRocChartId(i)),
                plotStats,
                plotThresholds,
                regenInferenceStats,
                true
              );
              this.plotChart(
                this.$$('#' + this.getPrChartId(i)),
                plotStats,
                plotThresholds,
                regenInferenceStats,
                false
              );
            }
            const plotStats = [];
            const plotThresholds = [];
            for (
              let modelInd = 0;
              modelInd < this.inferenceStats_.length;
              modelInd++
            ) {
              plotStats.push(this.inferenceStats_[modelInd].thresholds);
              plotThresholds.push(this.overallThresholds[modelInd].threshold);
            }
            this.plotChart(
              this.$$('#rocchart'),
              plotStats,
              plotThresholds,
              regenInferenceStats,
              true
            );
            this.plotChart(
              this.$$('#prchart'),
              plotStats,
              plotThresholds,
              regenInferenceStats,
              false
            );
          }
          // ROC and PR curves for the multi-class case
          else if (this.isMultiClass_(this.modelType, this.multiClass)) {
            const isSliced = this.featureValueThresholds.length > 0;
            const slices = isSliced
              ? this.featureValueThresholds.map((slice) =>
                  this.createCombinedValueString_(slice.value, slice.value2)
                )
              : [''];
            for (let sliceInd = 0; sliceInd < slices.length; sliceInd++) {
              const slice = slices[sliceInd];
              for (
                let labelInd = 0;
                labelInd < this.allConfMatrixLabels.length;
                labelInd++
              ) {
                const label = this.allConfMatrixLabels[labelInd];
                const plotStats = [];
                const plotThresholds = [];
                const thresholds = isSliced
                  ? this.featureValueThresholds[sliceInd].threshold
                  : this.overallThresholds;
                for (
                  let modelInd = 0;
                  modelInd < this.inferenceStats_.length;
                  modelInd++
                ) {
                  plotStats.push(
                    this.inferenceStats_[modelInd].allThresholds[slice][label]
                  );
                  plotThresholds.push(thresholds[modelInd].threshold);
                }
                this.plotChart(
                  this.$$(
                    '#' +
                      this.getRocChartLabelId(
                        labelInd,
                        isSliced ? sliceInd : ''
                      )
                  ),
                  plotStats,
                  plotThresholds,
                  regenInferenceStats,
                  true
                );
                this.plotChart(
                  this.$$(
                    '#' +
                      this.getPrChartLabelId(labelInd, isSliced ? sliceInd : '')
                  ),
                  plotStats,
                  plotThresholds,
                  regenInferenceStats,
                  false
                );
              }
            }
          }
          this.updateCorrectness_();
        },

        sortFeatureValues: function(values) {
          const inferenceStats = this.inferenceStats_[0];
          values = values.filter((a) => {
            if (this.isRegression_(this.modelType)) {
              return this.getRegressionCount(inferenceStats, a) > 0;
            } else if (
              this.isBinaryClassification_(this.modelType, this.multiClass)
            ) {
              return this.getBinaryClassificationCount(inferenceStats, a) > 0;
            } else {
              return (
                this.getMulticlassClassificationCount(inferenceStats, a) > 0
              );
            }
          });
          return values.sort((a, b) => {
            if (this.selectedFeatureSort == 'Count') {
              if (this.isRegression_(this.modelType)) {
                return (
                  this.getRegressionCount(inferenceStats, b) -
                  this.getRegressionCount(inferenceStats, a)
                );
              } else if (
                this.isBinaryClassification_(this.modelType, this.multiClass)
              ) {
                return (
                  this.getBinaryClassificationCount(inferenceStats, b) -
                  this.getBinaryClassificationCount(inferenceStats, a)
                );
              } else {
                return (
                  this.getMulticlassClassificationCount(inferenceStats, b) -
                  this.getMulticlassClassificationCount(inferenceStats, a)
                );
              }
            } else if (this.selectedFeatureSort == 'Alphabetical') {
              const aValue = this.getPrintableValue_(a);
              const bValue = this.getPrintableValue_(b);
              // Handle numeric intervals
              if (aValue[0] === '[' && bValue[0] === '[') {
                return (
                  Number.parseFloat(aValue.substring(1)) -
                  Number.parseFloat(bValue.substring(1))
                );
              }
              return aValue.localeCompare(bValue);
            } else if (this.selectedFeatureSort == 'Accuracy') {
              if (
                this.isBinaryClassification_(this.modelType, this.multiClass)
              ) {
                return (
                  +this.getAccuracyModelIndex(
                    this.inferenceStats_,
                    b.threshold,
                    0,
                    b
                  ) -
                  +this.getAccuracyModelIndex(
                    this.inferenceStats_,
                    a.threshold,
                    0,
                    a
                  )
                );
              } else {
                return (
                  +this.getMultiClassAccuracyModelIndex(
                    this.inferenceStats_,
                    0,
                    b
                  ) -
                  +this.getMultiClassAccuracyModelIndex(
                    this.inferenceStats_,
                    0,
                    a
                  )
                );
              }
            } else if (this.selectedFeatureSort == 'False positives') {
              return (
                +this.getFPModelIndex(this.inferenceStats_, b.threshold, 0, b) -
                +this.getFPModelIndex(this.inferenceStats_, a.threshold, 0, a)
              );
            } else if (this.selectedFeatureSort == 'False negatives') {
              return (
                this.getFNModelIndex(+this.inferenceStats_, b.threshold, 0, b) -
                +this.getFNModelIndex(this.inferenceStats_, a.threshold, 0, a)
              );
            }
          });
        },

        sortRegressionEntries: function(regressionEntries) {
          return regressionEntries.sort((a, b) => {
            if (this.selectedFeatureSort == 'Count') {
              return b.count - a.count;
            } else if (this.selectedFeatureSort == 'Alphabetical') {
              // Handle numeric intervals
              if (a.name[0] === '[' && b.name[0] === '[') {
                return (
                  Number.parseFloat(a.name.substring(1)) -
                  Number.parseFloat(b.name.substring(1))
                );
              }
              return a.name.localeCompare(b.name);
            } else if (this.selectedFeatureSort == 'Mean error') {
              return b.meanError - a.meanError;
            } else if (this.selectedFeatureSort == 'Mean absolute error') {
              return b.meanAbsError - a.meanAbsError;
            } else if (this.selectedFeatureSort == 'Mean squared error') {
              return b.meanSquaredError - a.meanSquaredError;
            } else if (this.selectedFeatureSort == 'Median error') {
              return b.medianError - a.medianError;
            } else if (this.selectedFeatureSort == 'Median absolute error') {
              return b.medianAbsError - a.medianAbsError;
            } else if (this.selectedFeatureSort == 'Median squared error') {
              return b.medianSquaredError - a.medianSquaredError;
            }
          });
        },

        fillInRegressionStats: function(regressionStats, name) {
          // From initial regression stats having regression error per example,
          // calculate error statistics.
          function mean(data) {
            const sum = data.reduce((sum, value) => {
              return sum + value;
            }, 0);

            return sum / data.length;
          }
          function median(data) {
            if (data.length == 0) {
              return NaN;
            }
            const sortedData = data.sort((a, b) => a - b);
            const midIndex = sortedData.length / 2;
            if (sortedData.length == 1) {
              return sortedData[0];
            } else if (sortedData.length % 2 == 0) {
              return sortedData[midIndex];
            } else {
              return (
                (sortedData[Math.floor(midIndex)] +
                  sortedData[Math.ceil(midIndex)]) /
                2
              );
            }
          }

          const absErrors = regressionStats.errors.map((err) => Math.abs(err));
          const squaredErrors = regressionStats.errors.map((err) => err * err);

          return {
            name: name,
            meanError: mean(regressionStats.errors),
            meanAbsError: mean(absErrors),
            meanSquaredError: mean(squaredErrors),
            medianError: median(regressionStats.errors),
            medianAbsError: median(absErrors),
            medianSquaredError: median(squaredErrors),
            count: regressionStats.errors.length,
          };
        },

        /**
         * Plots a PR or ROC purve given data to plot.
         * thresholdstats and thresholds are arrays, indexed by model number
         */
        plotChart: function(
          chart,
          thresholdStats,
          thresholds,
          regenInferenceStats,
          isRoc
        ) {
          if (!thresholdStats || !thresholdStats[0] || !chart) {
            return;
          }
          const visibleCharts = [];
          const seriesColors = [];
          const xAxis = isRoc ? 'FPR' : 'TPR';
          const yAxis = isRoc ? 'TPR' : 'PPV';
          const xAxisLabel = isRoc ? 'FPR' : 'Recall';
          const yAxisLabel = isRoc ? 'TPR' : 'Precision';
          for (let modelInd = 0; modelInd < thresholdStats.length; modelInd++) {
            let currentThresholdData = null;
            const data = thresholdStats[modelInd]
              .map((thresh, i) => {
                // This finds the furthest point on the line that is below the
                // current threshold
                if (i - thresholds[modelInd] * 100 < 0.5) {
                  currentThresholdData = {
                    step: thresh[xAxis],
                    scalar: thresh[yAxis],
                    threshold: i / 100,
                  };
                }
                return {
                  step: thresh[xAxis],
                  scalar: thresh[yAxis],
                  threshold: i / 100,
                };
              })
              .reverse();
            chart.setSeriesData(
              this.strWithModelName_('Threshold set', modelInd),
              [currentThresholdData]
            );
            if (regenInferenceStats) {
              chart.setSeriesData(
                this.strWithModelName_('ROC', modelInd),
                data
              );
              visibleCharts.push(this.strWithModelName_('ROC', modelInd));
              visibleCharts.push(
                this.strWithModelName_('Threshold set', modelInd)
              );
              seriesColors.push(this.rocCurveLineColors[modelInd]);
              seriesColors.push(this.rocCurveColors[modelInd]);
            }
          }
          if (regenInferenceStats) {
            const valueFormatter = d3.format('.2f');
            chart.xAxisFormatter = d3.format('.2f');
            const percentageFormatter = d3.format(',.1');
            const tooltipColumns = [
              {
                title: 'Threshold',
                evaluate: function(d) {
                  return valueFormatter(d.datum.threshold);
                },
              },
              {
                title: yAxisLabel,
                evaluate: function(d) {
                  return isRoc
                    ? percentageFormatter(d.datum.scalar)
                    : valueFormatter(d.datum.scalar);
                },
              },
              {
                title: xAxisLabel,
                evaluate: function(d) {
                  return isRoc
                    ? percentageFormatter(d.datum.step)
                    : valueFormatter(d.datum.step);
                },
              },
            ];
            // When more than one model is available, make tooltip show an extra
            // column for model id
            if (thresholdStats.length > 1) {
              tooltipColumns.push({
                title: 'Model',
                evaluate: function(d) {
                  const modelId = d.dataset.metadata().name.split(' ');
                  return modelId[modelId.length - 1];
                },
              });
            }
            chart.tooltipColumns = tooltipColumns;
            chart.colorScale = new Plottable.Scales.Color().range(seriesColors);
            chart.colorScale.domain(visibleCharts);
            chart.setVisibleSeries(visibleCharts);
          }
        },

        /**
         * Calculates TPR, FPR, and PPV given binary confusion matrix counts.
         */
        calcThresholdStats: function(stats) {
          for (let i = 0; i < stats.length; i++) {
            if (stats[i]['TP'] + stats[i]['FN'] > 0) {
              stats[i]['TPR'] =
                stats[i]['TP'] / (stats[i]['TP'] + stats[i]['FN']);
            } else {
              stats[i]['TPR'] = 0;
            }
            if (stats[i]['FP'] + stats[i]['TN'] > 0) {
              stats[i]['FPR'] =
                stats[i]['FP'] / (stats[i]['FP'] + stats[i]['TN']);
            } else {
              stats[i]['FPR'] = 0;
            }
            if (stats[i]['TP'] + stats[i]['FP'] > 0) {
              stats[i]['PPV'] =
                stats[i]['TP'] / (stats[i]['TP'] + stats[i]['FP']);
            } else {
              stats[i]['PPV'] = 0;
            }
          }
        },

        /**
         * Runs the appropriate threshold optimizer.
         */
        optimizationSelectedChanged_: function(selection) {
          if (selection == 'custom') {
            return;
          } else if (selection == 'unaware') {
            this.optimizeThresholdClicked_();
          } else if (selection == 'group') {
            this.optimizeFacetedThresholdsClicked_();
          } else if (selection == 'demoparity') {
            this.demoParityClicked_();
          } else if (selection == 'equalacc') {
            this.equalAccClicked_();
          } else if (selection == 'equalopp') {
            this.equalOppoClicked_();
          }
          this.updateInferenceStats_(true);
        },

        costRatioChanged_: function() {
          // When cost ratio changes, set optimization strategy
          // back to custom (default).
          this.resetOptimizationSelected_();
        },

        resetOptimizationSelected_: function() {
          const button = this.$$('#customthresh');
          if (button != null) {
            button.click();
          }
        },

        optimizeThresholdClicked_: function() {
          // Find the optimal threshold for all examples, then set all thresholds
          // to that value.
          for (
            let modelInd = 0;
            modelInd < this.inferenceStats_.length;
            modelInd++
          ) {
            const thresholdToSet = this.findOptimalThreshold_(
              this.inferenceStats_[modelInd].thresholds
            );
            this.set(
              'overallThresholds.' + modelInd + '.threshold',
              thresholdToSet
            );
            if (this.featureValueThresholds) {
              for (let i = 0; i < this.featureValueThresholds.length; i++) {
                const thresholdPath =
                  'featureValueThresholds.' +
                  i +
                  '.threshold.' +
                  modelInd +
                  '.threshold';
                this.set(thresholdPath, thresholdToSet);
              }
            }
          }
        },

        optimizeFacetedThresholdsClicked_: function() {
          // For each faceted set of examples, find the optimal threshold and
          // set it.
          for (
            let modelInd = 0;
            modelInd < this.inferenceStats_.length;
            modelInd++
          ) {
            const values = Object.keys(this.inferenceStats_[modelInd].faceted);
            for (let i = 0; i < values.length; i++) {
              const featureValue = values[i];
              const thresholdToSet = this.findOptimalThreshold_(
                this.inferenceStats_[modelInd].faceted[featureValue]
              );
              this.set(
                'featureValueThresholds.' +
                  i +
                  '.threshold.' +
                  modelInd +
                  '.threshold',
                thresholdToSet
              );
            }
          }
        },

        /**
         * Returns an optimal threshold from all classification thresholds.
         */
        findOptimalThreshold_: function(thresholds) {
          let minCost = Number.POSITIVE_INFINITY;
          let bestThreshold = 0;
          for (let i = 0; i < thresholds.length; i++) {
            const cost = this.getCost(thresholds[i]);
            if (cost <= minCost) {
              minCost = cost;
              bestThreshold = i;
            }
          }
          return bestThreshold / 100;
        },

        equalOppoClicked_: function() {
          // Find the optimal thresholds while maintaining equal opportunity.
          const measure = (stats) => stats['TP'] / (stats['TP'] + stats['FN']);
          this.getBestThresholdsByFairnessMeasure_(measure);
        },

        equalAccClicked_: function() {
          // Find the optimal thresholds while maintaining equal accuracy.
          const measure = (stats) =>
            (stats['TP'] + stats['TN']) /
            (stats['TP'] + stats['FP'] + stats['TN'] + stats['FN']);
          this.getBestThresholdsByFairnessMeasure_(measure);
        },

        demoParityClicked_: function() {
          // Find the optimal thresholds while maintaining demographic parity.
          const measure = (stats) =>
            (stats['TP'] + stats['FP']) /
            (stats['TP'] + stats['FP'] + stats['TN'] + stats['FN']);
          this.getBestThresholdsByFairnessMeasure_(measure);
        },

        getBestThresholdsByFairnessMeasure_: function(fairnessCalculator) {
          // For all thresholds for first facet:
          //   For all other facets:
          //     Find threshold with closest fairness measure of first facet at
          //     current threshold
          //   Calculate cost for these threshold settings settings across the
          //   facets, and save if the lowest.
          for (
            let modelInd = 0;
            modelInd < this.inferenceStats_.length;
            modelInd++
          ) {
            let minCost = Number.POSITIVE_INFINITY;
            let bestThresholds = null;
            const modelStats = this.inferenceStats_[modelInd];
            const values = Object.keys(modelStats.faceted);
            const firstFacet = modelStats.faceted[values[0]];
            for (let i = 0; i < firstFacet.length; i++) {
              const firstFacetMeasure = fairnessCalculator(firstFacet[i]);
              const facetThresholds = [i];
              let cost = this.getCost(firstFacet[i]);
              for (let facetIdx = 1; facetIdx < values.length; facetIdx++) {
                const currentFacet = modelStats.faceted[values[facetIdx]];
                const currentFacetThreshold = this.thresholdClosestToMeasure(
                  currentFacet,
                  firstFacetMeasure,
                  fairnessCalculator
                );
                facetThresholds.push(currentFacetThreshold);
                cost += this.getCost(currentFacet[currentFacetThreshold]);
              }
              if (cost <= minCost) {
                minCost = cost;
                bestThresholds = facetThresholds;
              }
            }

            // Set all thresholds to the setting with the lowest cost from the
            // above search.
            for (let vIdx = 0; vIdx < values.length; vIdx++) {
              const thresholdsIdx = this.featureValueThresholdsIndexMap[
                values[vIdx]
              ];
              this.set(
                'featureValueThresholds.' +
                  thresholdsIdx +
                  '.threshold.' +
                  modelInd +
                  '.threshold',
                bestThresholds[vIdx] / 100
              );
            }
          }
        },

        /**
         * Returns the cost of a classification threshold given the incorrect
         * inferences and the ratio of cost of false positives vs false negatives.
         */
        getCost: function(entries) {
          return entries['FP'] * this.incorrectPredCostRatio + entries['FN'];
        },

        /**
         * Helper function for finiding best thresholds with fairness measures.
         */
        thresholdClosestToMeasure: function(
          currentFacet,
          firstFacetMeasure,
          fairnessCalculator
        ) {
          let minDistance = Number.POSITIVE_INFINITY;
          let thresholdToReturn = 0;
          for (let i = 0; i < currentFacet.length; i++) {
            const measure = fairnessCalculator(currentFacet[i]);
            const curDistance = Math.abs(measure - firstFacetMeasure);
            if (curDistance <= minDistance) {
              thresholdToReturn = i;
              minDistance = curDistance;
            }
          }
          return thresholdToReturn;
        },

        /**
         * Finds the first inference label in the score-sorted list that is
         * non-zero.
         */
        getClassificationBestNonZero: function(index, modelIndex) {
          let indexForNonZeroLabel = 0;
          const inferenceIndex =
            this.examplesAndInferences[index].inferences.length - 1;
          for (
            let i = 0;
            i <
            this.examplesAndInferences[index].inferences[inferenceIndex][
              modelIndex
            ].length;
            i++
          ) {
            if (
              +this.examplesAndInferences[index].inferences[inferenceIndex][
                modelIndex
              ][i].label !== 0
            ) {
              indexForNonZeroLabel = i;
              break;
            }
          }
          return this.examplesAndInferences[index].inferences[inferenceIndex][
            modelIndex
          ][indexForNonZeroLabel];
        },

        /**
         * Gets confusion counts for a single model index modelInd
         */
        getConfusionCountsModelIndex: function(
          inferenceStats,
          thresholds,
          modelInd,
          item
        ) {
          // During updates inferenceStats and overallThresholds may get out of
          // sync, this if protects against indexing them before final state
          if (
            this.overallThresholds.length != this.numModels ||
            this.inferenceStats_.length != this.numModels
          ) {
            return {};
          } else {
            return this.getConfusionCounts(
              this.inferenceStats_[modelInd],
              thresholds[modelInd].threshold,
              item
            );
          }
        },

        /**
         * Returns the total number of entries in a confusion matrix.
         */
        getTotalEntriesInConfCounts: function(counts) {
          if (counts == null) {
            return 0;
          }
          let total = 0;
          const outerKeys = Object.keys(counts);
          for (let i = 0; i < outerKeys.length; i++) {
            const inner = counts[outerKeys[i]];
            const innerKeys = Object.keys(inner);
            for (let j = 0; j < innerKeys.length; j++) {
              total += inner[innerKeys[j]];
            }
          }
          return total;
        },

        /**
         * Returns the false positive percentage for a given confusion matrix
         * from the threshold selected, model index, and facet to view.
         */
        getFPModelIndex: function(inferenceStats, thresholds, modelInd, item) {
          // TODO(jameswex): This unnecessarily recalculates confusion matrix.
          // Can speed this up.
          const confCounts = this.getConfusionCountsModelIndex(
            inferenceStats,
            thresholds,
            modelInd,
            item
          );
          if (Object.keys(confCounts).length == 0) {
            return null;
          }
          const val = confCounts['No']['Yes'];
          return d3.format(',.1f')(
            (val / this.getTotalEntriesInConfCounts(confCounts)) * 100
          );
        },

        /**
         * Returns the false negative percentage for a given confusion matrix
         * from the threshold selected, model index, and facet to view.
         */
        getFNModelIndex: function(inferenceStats, thresholds, modelInd, item) {
          // TODO(jameswex): This unnecessarily recalculates confusion matrix.
          // Can speed this up.
          const confCounts = this.getConfusionCountsModelIndex(
            inferenceStats,
            thresholds,
            modelInd,
            item
          );
          if (Object.keys(confCounts).length == 0) {
            return 0;
          }
          const val = confCounts['Yes']['No'];
          return d3.format(',.1f')(
            (val / this.getTotalEntriesInConfCounts(confCounts)) * 100
          );
        },

        /**
         * Returns the accuracy percentage for a given confusion matrix
         * from the threshold selected, model index, and facet to view.
         */
        getAccuracyModelIndex: function(
          inferenceStats,
          thresholds,
          modelInd,
          item
        ) {
          // TODO(jameswex): This unnecessarily recalculates confusion matrix.
          // Can speed this up.
          const confCounts = this.getConfusionCountsModelIndex(
            inferenceStats,
            thresholds,
            modelInd,
            item
          );
          if (Object.keys(confCounts).length == 0) {
            return 0;
          }
          const val = confCounts['Yes']['Yes'] + confCounts['No']['No'];
          return d3.format(',.1f')(
            (val / this.getTotalEntriesInConfCounts(confCounts)) * 100
          );
        },

        /**
         * Returns the F1 score for a given confusion matrix
         * from the threshold selected, model index, and facet to view.
         */
        getF1ModelIndex: function(inferenceStats, thresholds, modelInd, item) {
          // TODO(jameswex): This unnecessarily recalculates confusion matrix.
          // Can speed this up.
          const formatter = d3.format(',.2f');
          const confCounts = this.getConfusionCountsModelIndex(
            inferenceStats,
            thresholds,
            modelInd,
            item
          );
          if (Object.keys(confCounts).length == 0) {
            return 0;
          }
          const truePositives = confCounts['Yes']['Yes'];
          const falsePositives = confCounts['No']['Yes'];
          const falseNegatives = confCounts['Yes']['No'];
          if (truePositives == 0) {
            if (falsePositives != 0 || falseNegatives != 0) {
              return formatter(0);
            } else {
              return formatter(1);
            }
          }
          const precision = truePositives / (truePositives + falsePositives);
          const recall = truePositives / (truePositives + falseNegatives);
          return formatter((2 * (precision * recall)) / (precision + recall));
        },

        /**
         * Returns the number of examples in a given facet.
         */
        getFeatureValueCount: function(inferenceStats, thresholds, item) {
          // TODO(jameswex): This unnecessarily recalculates confusion matrix.
          // Can speed this up.
          const confCounts = this.getConfusionCountsModelIndex(
            inferenceStats,
            thresholds,
            0,
            item
          );
          return this.getTotalEntriesInConfCounts(confCounts);
        },

        /**
         * Returns the label of a confusion matrix for a given model index.
         * When only using 1 model, no label is needed.
         */
        getConfusionMatrixLabel: function(index, numModels) {
          if (numModels < 2) {
            return '';
          }
          return this.getModelName_(index);
        },

        /**
         * Returns the background color of a confusion matrix based on
         * model index.
         */
        getConfusionMatrixColor: function(index) {
          return this.confMatrixColors[index];
        },

        /**
         * Gets binary confusion matrix counts from inference results.
         */
        getConfusionCounts(inferenceStats, threshold, item) {
          let val = null;
          let val2 = null;
          if (item != null) {
            val = item.value;
            val2 = item.value2;
          }
          return {
            No: {
              No: this.getConfMatrixValue(
                inferenceStats,
                threshold,
                'TN',
                val,
                val2
              ),
              Yes: this.getConfMatrixValue(
                inferenceStats,
                threshold,
                'FP',
                val,
                val2
              ),
            },
            Yes: {
              No: this.getConfMatrixValue(
                inferenceStats,
                threshold,
                'FN',
                val,
                val2
              ),
              Yes: this.getConfMatrixValue(
                inferenceStats,
                threshold,
                'TP',
                val,
                val2
              ),
            },
          };
        },

        /**
         * Helper method for getConfusionCounts
         */
        getConfMatrixValue: function(
          inferenceStats,
          threshold,
          stat,
          featureValue1,
          featureValue2
        ) {
          const index = Math.floor(threshold * 100);
          if (!inferenceStats.thresholds) {
            return 0;
          }
          if (featureValue1 === null) {
            return inferenceStats.thresholds[index][stat];
          }
          const key = this.createCombinedValueString_(
            featureValue1,
            featureValue2
          );
          if (inferenceStats.faceted[key] == null) {
            return 0;
          }
          return inferenceStats.faceted[key][index][stat];
        },

        /**
         * Gets multi-class confusion matrix from inference stats.
         */
        getMultiClassConfMatrix: function(inferenceStats, modelInd, facetItem) {
          if (inferenceStats.length == 0) {
            return {};
          } else if (facetItem == null) {
            return inferenceStats[modelInd].results;
          } else {
            const key = this.getPrintableValue_(facetItem);
            return inferenceStats[modelInd].faceted[key];
          }
        },

        /**
         * Returns the number of examples in a given facet from a
         * multi-class confusion matrix.
         */
        getMultiClassFeatureValueCount: function(inferenceStats, facetItem) {
          const confCounts = this.getMultiClassConfMatrix(
            inferenceStats,
            0,
            facetItem
          );
          return this.getTotalEntriesInConfCounts(confCounts);
        },

        /**
         * Returns the accuracy percentage for a given multi-class confusion
         * matrix from the threshold selected, model index, and facet to view.
         */
        getMultiClassAccuracyModelIndex: function(
          inferenceStats,
          modelInd,
          facetItem
        ) {
          const confCounts = this.getMultiClassConfMatrix(
            inferenceStats,
            modelInd,
            facetItem
          );
          if (confCounts == null) {
            return null;
          }
          let matches = 0;
          const outerKeys = Object.keys(confCounts);
          for (let i = 0; i < outerKeys.length; i++) {
            const inner = confCounts[outerKeys[i]];
            const innerKeys = Object.keys(inner);
            for (let j = 0; j < innerKeys.length; j++) {
              if (outerKeys[i] == innerKeys[j]) {
                matches += inner[innerKeys[j]];
              }
            }
          }
          return d3.format(',.1f')(
            (matches / this.getTotalEntriesInConfCounts(confCounts)) * 100
          );
        },

        /**
         * Gets a inference statistic from inference results.
         */
        getInferenceStat: function(
          inferenceStats,
          facetItem,
          getter,
          formatter
        ) {
          const stats = facetItem
            ? inferenceStats.faceted[this.getPrintableValue_(facetItem)]
            : inferenceStats.results;
          if (!stats) {
            return null;
          }
          const val = getter(stats);
          if (!formatter) {
            return val;
          } else {
            return formatter(val);
          }
        },

        getRegressionMean: function(regressionStats, facetItem) {
          return this.getInferenceStat(
            regressionStats,
            facetItem,
            (stat) => stat.mean,
            d3.format('.3f')
          );
        },

        getRegressionAbsMean: function(regressionStats, facetItem) {
          return this.getInferenceStat(
            regressionStats,
            facetItem,
            (stat) => stat.absMean,
            d3.format('.3f')
          );
        },

        getRegressionSquaredMean: function(regressionStats, facetItem) {
          return this.getInferenceStat(
            regressionStats,
            facetItem,
            (stat) => stat.squaredMean,
            d3.format('.3f')
          );
        },

        getRegressionCount: function(regressionStats, facetItem) {
          const count = this.getInferenceStat(
            regressionStats,
            facetItem,
            (stat) => stat.errors.length,
            null
          );
          if (count == null) {
            return 0;
          } else {
            return count;
          }
        },

        getBinaryClassificationCount: function(classificationStats, facetItem) {
          // stat[0] because we only need to count one threshold in binary case
          return this.getInferenceStat(
            classificationStats,
            facetItem,
            (stat) => Object.values(stat[0]).reduce((a, b) => a + b),
            null
          );
        },

        getMulticlassClassificationCount: function(
          classificationStats,
          facetItem
        ) {
          // stat because in multi class case inferenceStats does not have
          // thresholds
          return this.getInferenceStat(
            classificationStats,
            facetItem,
            (stat) =>
              Object.values(stat).reduce((a, b) => {
                let total = 0;
                const iKeys = Object.keys(b);
                for (let i = 0; i < iKeys.length; i++) {
                  total += b[iKeys[i]];
                }
                return a + total;
              }, 0),
            null
          );
        },

        getRocChartId: function(index) {
          return 'rocchart' + index;
        },

        getRocChartLabelId: function(label, index) {
          return this.getRocChartId(index) + '-' + label;
        },

        getLabel: function(index) {
          return this.labelVocab[index] || index;
        },

        getPrChartId: function(index) {
          return 'prchart' + index;
        },

        getPrChartLabelId: function(label, index) {
          return this.getPrChartId(index) + '-' + label;
        },

        /**
         * Returns a printable value for a breakdown item, meaning performance
         * statistics broken down by feature values or feature crosses.
         */
        getPrintableValue_: function(item) {
          let str = '';
          if (!item.value && item.value !== 0) {
            str = '<feature value missing>';
          } else {
            str = String(item.value);
          }
          if (this.selectedSecondBreakdownFeature == '') {
            return str;
          }
          str += '/';
          if (!item.value2 && item.value2 !== 0) {
            str += '<feature value missing>';
          } else {
            str += item.value2;
          }
          return str;
        },

        getFeatureName_: function(feature) {
          // If feature name is blank then this represents selecting no feature.
          if (feature.length === 0) {
            return '<none>';
          }
          return feature;
        },

        getCounterfactualModelName_: function(modelName) {
          return 'Model: ' + modelName;
        },

        getClassName_: function(cls) {
          // If class name is blank then this represents selecting no class.
          if (cls.length === 0) {
            return '<none>';
          }
          return cls;
        },

        shouldShowOverallThresholder_: function(feature) {
          return feature.length === 0;
        },

        /**
         * Sets the selected example from the facets dive selection.
         */
        computeSelectedExampleAndInference: function() {
          this.counterfactualExampleAndInference = null;
          if (!this.selected || !this.examplesAndInferences) {
            this.selectedExampleAndInference = null;
            return;
          }
          this.selectedExampleAndInference =
            this.selected.length > 0
              ? this.examplesAndInferences[this.selected[0]]
              : null;
          if (this.selectedExampleAndInference == null) {
            this.globalPdPlots = true;
          } else {
            this.globalPdPlots = false;
            if (this.visMode != 'dive') {
              this.showPartialDependencePlots_();
            }
          }
        },

        /**
         * Finds attribution features and sets the attribution object for the
         * selected example.
         */
        setAttributions: function() {
          const attrib = {};
          const selectedData = this.visdata[this.selected[0]];
          const attributionFinder = new RegExp(attributionPrefix + '(.*)');
          const sparseAttributionFinder = new RegExp(
            attributionPrefix + '(.*)' + attributionSparseKeySuffix
          );
          for (let key in selectedData) {
            let featureWithAttribution = attributionFinder.exec(key);
            // If this feature represents an attribution, set the attribution
            // value for the appropriate example feature.
            // Attribution is represented by features with the format
            // "{attributionPrefix}{featureName}".
            if (featureWithAttribution) {
              const featFinder = new RegExp(
                '^(' +
                  featureForAttributionPrefix +
                  ')?' +
                  featureWithAttribution[1] +
                  '$'
              );
              for (let featToTest in selectedData) {
                if (featFinder.test(featToTest)) {
                  attrib[featToTest] = selectedData[key];
                  break;
                }
              }
            }
            featureWithAttribution = sparseAttributionFinder.exec(key);
            // If this feature represents a sparse attribution, set the
            // attribution values for the appropriate example feature.
            // "{attributionPrefix}{featureName}{attributionSparseKeySuffix}"
            // containing a list of feature values for which we have attribution
            // values and
            // "{attributionPrefix}{featureName}{attributionSparseValueSuffix}"
            // containing a same-sized list of attribution amounts for those
            // feature values.
            if (featureWithAttribution) {
              const featFinder = new RegExp(
                '^(' +
                  featureForAttributionPrefix +
                  ')?' +
                  featureWithAttribution[1] +
                  '$'
              );
              for (let featToTest in selectedData) {
                if (featFinder.test(featToTest)) {
                  const attribKeys = selectedData[key];
                  const attribVals =
                    selectedData[
                      key.replace(
                        attributionSparseKeySuffix,
                        attributionSparseValueSuffix
                      )
                    ];
                  const len = Array.isArray(selectedData[featToTest])
                    ? selectedData[featToTest].length
                    : 1;
                  const attribList = Array.apply(null, Array(len)).map(
                    Number.prototype.valueOf,
                    0
                  );
                  for (
                    let attribIdx = 0;
                    attribIdx < attribKeys.length;
                    attribIdx++
                  ) {
                    let valIndex = selectedData[featToTest].indexOf(
                      attribKeys[attribIdx]
                    );
                    if (valIndex != -1) {
                      attribList[valIndex] = attribVals[attribIdx];
                    }
                  }
                  attrib[featToTest] = attribList;
                  break;
                }
              }
            }
          }
          this.attribution = attrib;
        },

        shouldDisableGetExamplesButton_: function(examplesPath) {
          return examplesPath.length == 0;
        },

        shouldDisableInferButton_: function(
          examples,
          modelName,
          inferenceAddress,
          updatedExample
        ) {
          return (
            examples.length == 0 ||
            modelName.length == 0 ||
            inferenceAddress.length == 0 ||
            !updatedExample
          );
        },

        areExamplesEditable_: function(modelName, inferenceAddress) {
          return modelName.length != 0 && inferenceAddress.length != 0;
        },

        newInferences_: function() {
          this.spinnerHidden_ = true;
          this.updateInferences_(true);
          requestAnimationFrame(() => this.updateInferenceStats_(true));
        },

        refreshInferencesNoRegen_: function() {
          this.refreshInferences_(true);
          requestAnimationFrame(() => this.updateInferenceStats_(true));
        },

        refreshInferences_: function(noRegen) {
          this.updateInferences_(false);
          requestAnimationFrame(() => this.updateInferenceStats_(!noRegen));
        },

        /**
         * Updates inference results.
         */
        updateInferences_: function(newInferencesCalculated) {
          if (
            !this.examplesAndInferences ||
            !this.inferences.indices ||
            this.inferences.indices.length == 0 ||
            this.inferences.results.length != this.numModels
          ) {
            return;
          }
          // Create map of example indices to inference results.
          // inferenceMap: sample id -> # Models -> # Labels
          const inferenceMap = {};
          const isClassification = !!this.inferences.results[0]
            .classificationResult;
          for (let i = 0; i < this.inferences.indices.length; i++) {
            if (isClassification) {
              inferenceMap[this.inferences.indices[i]] = [];
              for (
                let modelNum = 0;
                modelNum < this.inferences.results.length;
                modelNum++
              ) {
                const result = this.inferences.results[modelNum]
                  .classificationResult;
                // For models that don't return any labels for the classes, fill
                // them out with class indices.
                for (
                  let j = 0;
                  j < result.classifications[i].classes.length;
                  j++
                ) {
                  if (result.classifications[i].classes[j].label == '') {
                    result.classifications[i].classes[j].label = j.toString();
                  }
                }
                inferenceMap[this.inferences.indices[i]][
                  modelNum
                ] = result.classifications[i].classes.sort(
                  (a, b) => b.score - a.score
                );
              }
            } else {
              inferenceMap[this.inferences.indices[i]] = [];
              for (
                let modelNum = 0;
                modelNum < this.inferences.results.length;
                modelNum++
              ) {
                const result = this.inferences.results[modelNum]
                  .regressionResult;
                inferenceMap[this.inferences.indices[i]][modelNum] = [
                  {label: '', score: result.regressions[i].value},
                ];
              }
            }
          }
          // Set the inferences in the examplesAndInferences structure, updating
          // for new inferences where appropriate.
          this.set(
            'examplesAndInferences',
            this.examplesAndInferences.map(function(item, index) {
              let inferences = item.inferences ? item.inferences : [];
              if (inferenceMap[index] && newInferencesCalculated) {
                inferences = inferences.concat([inferenceMap[index]]);
              }
              return {
                example: item.example,
                inferences: inferences,
                changed: item.changed,
                orig: item.orig,
              };
            })
          );
          const self = this;
          let hasInferenceLabels = false;
          this.visdata.forEach(function(item, index) {
            if (isClassification) {
              self.setItemInferenceValue(
                item,
                index,
                self.selectedBreakdownFeature,
                self.selectedSecondBreakdownFeature
              );
            } else {
              for (let modelInd = 0; modelInd < self.numModels; modelInd++) {
                item[self.strWithModelName_(inferenceValueStr, modelInd)] =
                  self.examplesAndInferences[index].inferences[
                    self.examplesAndInferences[index].inferences.length - 1
                  ][modelInd][0].score;
              }
            }

            // If there is a label vocab for classification, set the string
            // inferred label for each example.
            if (isClassification && self.labelVocab.length > 0) {
              for (
                let inferenceIndex = 0;
                inferenceIndex <
                self.examplesAndInferences[index].inferences.length;
                inferenceIndex++
              ) {
                for (
                  let modelNum = 0;
                  modelNum <
                  self.examplesAndInferences[index].inferences[inferenceIndex]
                    .length;
                  modelNum++
                ) {
                  for (
                    let labelIndex = 0;
                    labelIndex <
                    self.examplesAndInferences[index].inferences[
                      inferenceIndex
                    ][modelNum].length;
                    labelIndex++
                  ) {
                    self.examplesAndInferences[index].inferences[
                      inferenceIndex
                    ][modelNum][labelIndex].vocabLabel =
                      self.labelVocab[
                        self.examplesAndInferences[index].inferences[
                          inferenceIndex
                        ][modelNum][labelIndex].label
                      ];
                  }
                }
              }
              for (let modelInd = 0; modelInd < self.numModels; modelInd++) {
                item[self.strWithModelName_(inferenceLabelStr, modelInd)] =
                  self.labelVocab[
                    item[self.strWithModelName_(inferenceValueStr, modelInd)]
                  ];
              }
              hasInferenceLabels = true;
            }
          });
          this.updateCorrectness_();
          this.refreshDive_();

          // If inferring for the first time, set the color in facets dive to
          // inference results of the first model and use positioning to show
          // inference scores. When reinferring from changes, don't override
          // whatever options have been set.
          if (
            this.inferences.indices.length == this.examplesAndInferences.length
          ) {
            this.$.dive.colorBy = hasInferenceLabels
              ? this.strWithModelName_(inferenceLabelStr, 0)
              : this.strWithModelName_(inferenceValueStr, 0);
            if (this.isRegression_(this.modelType)) {
              this.$.dive.horizontalPosition = this.strWithModelName_(
                inferenceValueStr,
                0
              );
              if (this.numModels > 1) {
                this.$.dive.verticalPosition = this.strWithModelName_(
                  inferenceValueStr,
                  1
                );
              }
            } else if (
              this.isBinaryClassification_(this.modelType, this.multiClass)
            ) {
              if (this.numModels == 1) {
                this.$.dive.verticalPosition = this.strWithModelName_(
                  inferenceScoreStr,
                  0
                );
              } else {
                this.$.dive.horizontalPosition = this.strWithModelName_(
                  inferenceScoreStr,
                  0
                );
                this.$.dive.verticalPosition = this.strWithModelName_(
                  inferenceScoreStr,
                  1
                );
              }
            }
          }
          this.updatedExample = false;
        },

        hasAttributions_: function(attributions) {
          return (
            attributions != null &&
            Object.keys(attributions.attributions).length != 0 &&
            attributions.attributions[0] != null
          );
        },

        newExtraOutputs_: function(extraOutputs) {
          // Set attributions from the extra outputs, if available.
          const attributions = [];
          for (
            let modelNum = 0;
            modelNum < extraOutputs.extra.length;
            modelNum++
          ) {
            if (
              extraOutputs.extra[modelNum] != null &&
              'attributions' in extraOutputs.extra[modelNum]
            ) {
              attributions.push(extraOutputs.extra[modelNum].attributions);
            }
          }
          if (attributions.length > 0) {
            this.attributions = {
              indices: extraOutputs.indices,
              attributions: attributions,
            };
          }

          // Add extra output information to datapoints
          for (let i = 0; i < extraOutputs.indices.length; i++) {
            const idx = extraOutputs.indices[i];
            const datapoint = Object.assign({}, this.visdata[idx]);
            for (
              let modelNum = 0;
              modelNum < extraOutputs.extra.length;
              modelNum++
            ) {
              if (extraOutputs.extra[modelNum] == null) {
                continue;
              }
              const keys = Object.keys(extraOutputs.extra[modelNum]);
              for (let j = 0; j < keys.length; j++) {
                const key = keys[j];
                // Skip attributions as they are handled separately above.
                if (key == 'attributions') {
                  continue;
                }
                let val = extraOutputs.extra[modelNum][key][i];
                const datapointKey = this.strWithModelName_(key, modelNum);

                // Update the datapoint with the extra info for use in
                // Facets Dive.
                datapoint[datapointKey] = val;

                // Convert the extra output into an array if necessary, for
                // insertion into tf.Example as a value list, for update of
                // examplesAndInferences for the example viewer.
                if (!Array.isArray(val)) {
                  val = [val];
                }
                const isString =
                  val.length > 0 &&
                  (typeof val[0] == 'string' || val[0] instanceof String);
                const exampleJsonString = JSON.stringify(
                  this.examplesAndInferences[idx].example
                );
                const copiedExample = JSON.parse(exampleJsonString);
                copiedExample.features.feature[datapointKey] = isString
                  ? {bytesList: {value: val}}
                  : {floatList: {value: val}};
                this.examplesAndInferences[idx].example = copiedExample;
              }
            }
            this.set(`visdata.${idx}`, datapoint);
          }
          this.refreshDive_();

          // Update selected datapoint so that if a datapoint is being viewed,
          // the display is updated with the appropriate extra output.
          this.computeSelectedExampleAndInference();
          this.refreshSelectedDatapoint_();
        },

        newAttributions_: function(attributions) {
          if (!this.hasAttributions_(attributions)) {
            return;
          }
          for (let i = 0; i < attributions.indices.length; i++) {
            const idx = attributions.indices[i];
            const datapoint = Object.assign({}, this.visdata[idx]);
            // TODO(jwexler): Support attributions from multiple models.
            // For now, we only display attribution from the first model, if WIT
            // is loaded with two models.
            const attribs =
              attributions.attributions[0] == null
                ? {}
                : attributions.attributions[0][i];
            const keys = Object.keys(attribs);
            for (let j = 0; j < keys.length; j++) {
              // If the attributions for a key is a 2D array then treat the first
              // entry as sparse keys for attributions and the second entry as
              // the attributions for the sparse keys in the first array.
              // Otherwise the attribution is a single value or list and can be
              // used as such.
              let attribKey = attributionPrefix + keys[j];
              if (
                Array.isArray(attribs[keys[j]]) &&
                attribs[keys[j]].length == 2 &&
                Array.isArray(attribs[keys[j]][0])
              ) {
                const attribSparseKeyKey =
                  attributionPrefix + keys[j] + attributionSparseKeySuffix;
                datapoint[attribSparseKeyKey] = attribs[keys[j]][0];
                attribKey =
                  attributionPrefix + keys[j] + attributionSparseValueSuffix;
                datapoint[attribKey] = attribs[keys[j]][1];
              } else {
                datapoint[attribKey] = attribs[keys[j]];
              }
              let newAttributions = Array.isArray(datapoint[attribKey])
                ? datapoint[attribKey]
                : [datapoint[attribKey]];
              for (
                let attribIdx = 0;
                attribIdx < newAttributions.length;
                attribIdx++
              ) {
                if (newAttributions[attribIdx] > this.maxAttribution) {
                  this.maxAttribution = newAttributions[attribIdx];
                }
                if (newAttributions[attribIdx] < this.minAttribution) {
                  this.minAttribution = newAttributions[attribIdx];
                }
              }
            }
            this.set(`visdata.${idx}`, datapoint);
          }
          // Make min/max symmetric around 0 so that attribution visualization scales
          // for negative and positive attributions are the same, for visual
          // consistency.
          if (
            this.minAttribution < 0 &&
            this.maxAttribution > Math.abs(this.minAttribution)
          ) {
            this.minAttribution = -1 * this.maxAttribution;
          } else if (
            this.maxAttribution > 0 &&
            Math.abs(this.minAttribution) > this.maxAttribution
          ) {
            this.maxAttribution = -1 * this.minAttribution;
          }
          this.setAttributions();
          this.createAttributionLegend();
          this.refreshDive_();
        },

        // Create and display the attribution legend.
        createAttributionLegend: function() {
          let attributionDomain = [];
          let attributionColorRange = [];
          if (this.minAttribution < 0) {
            attributionDomain.push(this.minAttribution);
            attributionColorRange.push(negAttributionHighColor);
            attributionDomain.push(this.minAttribution / 2);
            attributionColorRange.push(negAttributionLowColor);
          }
          attributionDomain.push(0);
          attributionColorRange.push(neutralAttributionColor);
          if (this.maxAttribution > 0) {
            attributionDomain.push(this.maxAttribution / 2);
            attributionColorRange.push(posAttributionLowColor);
            attributionDomain.push(this.maxAttribution);
            attributionColorRange.push(posAttributionHighColor);
          }

          this.attributionColorScale = d3
            .scaleLinear()
            .domain(attributionDomain)
            .interpolate(COLOR_INTERPOLATOR)
            .clamp(true)
            .range(attributionColorRange);

          const attrLegend = Polymer.dom(this.root).querySelector(
            '#attributionLegend'
          );
          d3.select(attrLegend)
            .selectAll('*')
            .remove();
          const legendSvg = d3.select(attrLegend).append('g');
          const gradient = legendSvg
            .append('defs')
            .append('linearGradient')
            .attr('id', 'vzexampleviewergradient')
            .attr('x1', '0%')
            .attr('y1', '0%')
            .attr('x2', '100%')
            .attr('y2', '0%')
            .attr('spreadMethod', 'pad');

          const linspace = (start, end, n) => {
            const out = [];
            const delta = (end - start) / (n - 1);
            let i = 0;
            while (i < n - 1) {
              out.push(start + i * delta);
              i++;
            }
            out.push(end);
            return out;
          };

          // Set 3 ticks on the legend, handling all positive, all negative,
          // or a mix of both.
          const ticks = [];
          if (attributionColorRange.length == 5) {
            ticks.push(this.minAttribution / 2);
            ticks.push(0);
            ticks.push(this.maxAttribution / 2);
          } else if (this.minAttribution < 0) {
            ticks.push((this.minAttribution / 4) * 3);
            ticks.push(this.minAttribution / 2);
            ticks.push((this.minAttribution / 4) * 1);
          } else {
            ticks.push((this.maxAttribution / 4) * 1);
            ticks.push(this.maxAttribution / 2);
            ticks.push((this.maxAttribution / 4) * 3);
          }
          // Creates an array of [pct, colour] pairs as stop
          // values for legend
          const pct = linspace(0, 100, attributionColorRange.length).map(
            (d) => {
              return Math.round(d) + '%';
            }
          );

          const colourPct = d3.zip(pct, attributionColorRange);

          colourPct.forEach((d) => {
            gradient
              .append('stop')
              .attr('offset', d[0])
              .attr('stop-color', d[1])
              .attr('stop-opacity', 1);
          });

          legendSvg
            .append('rect')
            .attr('x1', 0)
            .attr('y1', 0)
            .attr('width', LEGEND_WIDTH_PX)
            .attr('height', LEGEND_HEIGHT_PX)
            .style('fill', 'url(#vzexampleviewergradient)');

          const legendScale = d3
            .scaleLinear()
            .domain([this.minAttribution, this.maxAttribution])
            .range([0, LEGEND_WIDTH_PX]);

          const legendAxis = d3
            .axisBottom(legendScale)
            .tickValues(ticks)
            .tickSize(4)
            .tickFormat(d3.format('.1f'));

          legendSvg
            .append('g')
            .attr('class', 'legend axis')
            .attr('transform', `translate(0,${LEGEND_HEIGHT_PX})`)
            .style('font', '9px')
            .call(legendAxis);
        },

        /**
         * Helper method for setting inference value for classifications.
         */
        setItemInferenceValue: function(item, index, feature1, feature2) {
          const inferenceIdx =
            this.examplesAndInferences[index].inferences.length - 1;
          if (this.multiClass) {
            for (let i = 0; i < this.numModels; i++) {
              item[
                this.strWithModelName_(inferenceValueStr, i)
              ] = this.examplesAndInferences[index].inferences[inferenceIdx][
                i
              ][0].label;
            }
            return;
          }

          // Binary classifier case.
          let thresholds = this.overallThresholds;
          // If a feature has been selected (string will be non-empty in this
          // case), then get the appropriate threshold for this item's value for
          // that feature. Otherwise the overall threshold will be used.
          if (feature1.length !== 0) {
            let key = this.getSliceKey_(
              item,
              this.selectedBreakdownFeature,
              this.selectedSecondBreakdownFeature
            );
            thresholds = this.featureValueThresholds[
              this.featureValueThresholdsIndexMap[key]
            ].threshold;
          }
          for (let modelNum = 0; modelNum < this.numModels; modelNum++) {
            const nonZeroClassification = this.getClassificationBestNonZero(
              index,
              modelNum
            );
            item[this.strWithModelName_(inferenceScoreStr, modelNum)] =
              nonZeroClassification.score;
            if (nonZeroClassification.score >= thresholds[modelNum].threshold) {
              item[this.strWithModelName_(inferenceValueStr, modelNum)] =
                nonZeroClassification.label;
            } else {
              item[
                this.strWithModelName_(inferenceValueStr, modelNum)
              ] = this.defaultInferenceLabel.toString();
            }
          }
        },

        createCombinedValueString_: function(val1, val2) {
          let str = val1 === undefined || val1 === null ? '' : val1;
          if (val2 === undefined || val2 === null || val2 === '') {
            return str;
          }
          return str + '/' + val2;
        },

        /**
         * Updates per-item results for display in facets dive based on inference.
         */
        updateCorrectness_: function() {
          if (!this.selectedLabelFeature || !this.examplesAndInferences) {
            return;
          }
          for (let i = 0; i < this.examplesAndInferences.length; i++) {
            const item = this.visdata[i];
            for (let modelInd = 0; modelInd < this.numModels; modelInd++) {
              if (this.modelType == 'classification') {
                item[this.strWithModelName_(inferenceCorrectStr, modelInd)] =
                  item[this.selectedLabelFeature] ==
                  item[this.strWithModelName_(inferenceValueStr, modelInd)]
                    ? 'correct'
                    : 'incorrect';
              } else {
                item[this.strWithModelName_(inferenceErrorStr, modelInd)] =
                  item[this.strWithModelName_(inferenceValueStr, modelInd)] -
                  item[this.selectedLabelFeature];
                item[
                  this.strWithModelName_(inferenceAbsErrorStr, modelInd)
                ] = Math.abs(
                  item[this.strWithModelName_(inferenceErrorStr, modelInd)]
                );
                item[
                  this.strWithModelName_(inferenceSquaredErrorStr, modelInd)
                ] =
                  item[this.strWithModelName_(inferenceErrorStr, modelInd)] *
                  item[this.strWithModelName_(inferenceErrorStr, modelInd)];
              }
            }
          }
        },

        /**
         * Handler for when running inference, calls the backend.
         */
        inferClicked_: function() {
          const inferParams = {
            inference_address: this.inferenceAddress,
            model_name: this.modelName,
            model_type: this.modelType,
            model_version: this.modelVersion,
            model_signature: this.modelSignature,
            label_vocab_path: this.labelVocabPath,
            use_predict: this.usePredictApi,
            predict_output_tensor: this.predictOutputTensor,
            predict_input_tensor: this.predictInputTensor,
          };
          this.spinnerHidden_ = false;
          if (!this.local) {
            const url = this.makeUrl_('/data/plugin/whatif/infer', inferParams);
            const inferContents = (result) => {
              this.spinnerHidden_ = true;
              this.labelVocab = /** @type {!Array} */ (JSON.parse(
                result.value.vocab
              ));
              this.inferences = /** @type {!Object} */ (JSON.parse(
                result.value.inferences
              ));
            };
            this.makeAsyncRequest_(url, inferContents, null, 'model inference');
          }
          this.fire('infer-examples', inferParams);
        },

        /**
         * Handler for an example being changed by user input.
         */
        exampleChange_: function(event) {
          var id = 0;
          var index = this.selected.length == 0 ? id : this.selected[id];
          this.set('selectedExampleAndInference.changed', true);
          this.updateExample_(JSON.stringify(event.target.json), index);
          const inferenceViewerIdStr = '#' + this.getInferenceHolderId_();
          const inferenceViewer = this.$$(inferenceViewerIdStr);
          inferenceViewer.inference = null;
          this.visdata[index] = this.exampleToDataPoint_(
            event.target.json,
            index
          );
          this.showNearestCounterfactual = false;
          this.refreshDive_();
          this.updatedExample = true;
          this.selectedDataUpdated_();
        },

        refreshDiveImpl_: function() {
          const temp = this.visdata;
          this.visdata = [];
          this.visdata = temp;
          this.selectedExampleMax = this.visdata.length - 1;
          this.$.overview.protoInput = this.$.overview.getStatsProto([
            {name: '', data: temp},
          ]);
          this.calculateDistanceStats_(this.$.overview.protoInput.toObject());
          if (this.isRegression_(this.modelType)) {
            this.adjustMinCounterfactualValueDist_();
          }
          const tempSelected = this.$.dive.selectedData;
          this.$.dive.selectedData = [];
          this.$.dive.selectedData = tempSelected;
          this.updateSprite();
        },

        refreshDive_: function() {
          // Debounce a refresh request, for when multiple updates are happening
          // in succession.
          this.debounce(
            'refreshDiveDebounce',
            () => this.refreshDiveImpl_(),
            500
          );
        },

        /**
         * Calculates and stores distance stats for each feature, used for
         * calculating distances between examples.
         */
        calculateDistanceStats_: function(statsProto) {
          this.distanceStats_ = {};
          for (
            let i = 0;
            i < statsProto.datasetsList[0].featuresList.length;
            i++
          ) {
            const featureStats = statsProto.datasetsList[0].featuresList[i];
            const feature = featureStats.name;
            this.distanceStats_[feature] = {
              isNumeric: featureStats.numStats != null,
            };
            if (this.distanceStats_[feature].isNumeric) {
              // Numeric features:
              this.distanceStats_[feature].stdDev =
                featureStats.numStats.stdDev;
            } else {
              // Categorical features: calculate and store the probability
              // that any two feature values across all examples are the same.
              let probSameValue = 0;
              const buckets =
                featureStats.stringStats.rankHistogram.bucketsList;
              for (let j = 0; j < buckets.length; j++) {
                const probEntry =
                  buckets[j].sampleCount /
                  featureStats.stringStats.commonStats.numNonMissing;
                probSameValue += probEntry * probEntry;
              }
              this.distanceStats_[feature].probSameValue = probSameValue;
            }
          }
        },

        /**
         * Whether the feature is numeric (as opposed to categorical).
         */
        isNumericFeature_: function(feature) {
          return (
            feature &&
            this.distanceStats_ &&
            this.distanceStats_[feature] &&
            this.distanceStats_[feature].isNumeric
          );
        },

        /**
         * Calculate edges between buckets for aggregating numeric features.
         * We do this beforehand to round numbers and avoid ugly interval labels.
         */
        calculateBucketEdges_: function(feature, numBuckets) {
          if (
            !this.isNumericFeature_(feature) ||
            // No point in aggregating if not more unique values than buckets.
            this.stats[feature].uniqueCount <= numBuckets ||
            // Already done.
            (this.featureBucketEdges_[feature] &&
              this.featureBucketEdges_[feature].length == numBuckets + 1)
          ) {
            delete this.featureBucketEdges_[feature];
            return;
          }
          const min = this.stats[feature].numberMin;
          const max = this.stats[feature].numberMax;
          const len = (max - min) / numBuckets;
          const stdDev = this.distanceStats_[feature].stdDev;
          function round(val) {
            // Round to slightly more precise than the magnitude of standard deviation.
            const precision = -Math.floor(Math.log10(stdDev)) + 1;
            return Math.round(val * 10 ** precision) / 10 ** precision;
          }
          const bucketEdges = [];
          bucketEdges.push(min);
          for (let i = 1; i < numBuckets; i++) {
            bucketEdges.push(round(min + i * len));
          }
          bucketEdges.push(max);
          this.featureBucketEdges_[feature] = bucketEdges;
        },

        /**
         * Calls the backend to update a changed example.
         */
        updateExample_: function(exampleJson, index) {
          this.fire('update-example', {example: exampleJson, index: index});
          if (!this.local) {
            var url = this.makeUrl_('/data/plugin/whatif/update_example', null);

            this.makeAsyncRequest_(
              url,
              null,
              {example: exampleJson, index: index},
              'datapoint update'
            );
          }
        },

        getInferenceHolderId_: function() {
          return 'inference_';
        },

        makeUrl_: function(prefix, paramsDict) {
          const url = prefix;
          if (paramsDict) {
            prefix +=
              '?' +
              Object.keys(paramsDict)
                .map((k) => k + '=' + encodeURIComponent(paramsDict[k]))
                .join('&');
          }
          return prefix;
        },

        showToast_: function(msg) {
          var toast = document.createElement('paper-toast');
          toast.duration = 10000;
          document.body.appendChild(toast);
          toast.text = msg;
          toast.show();

          // Also, log to console.
          console.error(msg);
        },

        handleError: function(errorStr) {
          this.showToast_(errorStr);
          this.exampleStatusStr = errorStr;
          this.spinnerHidden_ = true;
          this.isSortingEligibleFeatures = false;
        },

        makeAsyncRequest_: function(
          url,
          thenDoFn,
          postData,
          readableRequestName,
          errorFn = () => {}
        ) {
          const wrapperFn = this._canceller.cancellable((result) => {
            if (result.cancelled) {
              return;
            }
            if (result.value && result.value.error) {
              this.handleError(result.value.error);
              if (errorFn != null) {
                errorFn();
              }
            } else if (thenDoFn) {
              thenDoFn(result);
            }
          });
          this._requestManager
            .request(url, postData)
            .then(wrapperFn)
            .catch((reason) => {
              this.handleError(
                `Request for ${readableRequestName} failed: ${reason}`
              );
              if (errorFn != null) {
                errorFn();
              }
            });
        },

        /**
         * Extract the data point feature value from an example feature. If
         * squeeze is true then convert length 1 arrays into single objects.
         */
        dataPointValueFromFeature_: function(feature, squeeze) {
          let valueList = null;
          if (feature.int64List) {
            valueList = feature.int64List.value;
          } else if (feature.floatList) {
            valueList = feature.floatList.value;
          } else if (feature.bytesList && feature.bytesList.value) {
            valueList = feature.bytesList.value.map((val) => {
              // Strings above a max length are most likely binary encoded data
              // and not strings and therefore shouldn't be decoded for display
              // in Facets Dive.
              if (val.length > maxStringLengthToDecode) {
                return 'ERROR: string not decoded due to length';
              }
              try {
                return atob(val);
              } catch (err) {
                console.error('Error decoding string: ' + err);
                return 'ERROR: error decoding string';
              }
            });
          }
          // For value lists that are of length 1, treat the feature value
          // as just the item and not the list of length 1.
          if (squeeze && valueList && valueList.length == 1) {
            let singleValue = valueList[0];
            // For numeric feature values, convert the string to a number.
            if (!isNaN(singleValue)) {
              return Number(singleValue);
            } else {
              return singleValue;
            }
          }
          return valueList;
        },

        /**
         * Converts a single TF Example or SequenceExample into an item dict for
         * display in Facets Dive.
         */
        exampleToDataPoint_: function(example, index) {
          const d = {};
          // Extract the standard features from examples or context features from
          // sequence examples.
          const featureRoot = example.features || example.context;
          const features =
            featureRoot && 'feature' in featureRoot
              ? Object.keys(featureRoot.feature)
              : [];
          for (const index in features) {
            const fname = features[+index];
            // Ignore encoded image feature when creating data for Facets Dive.
            // The image will instead be used for the display sprite for the item
            // in Dive.
            if (fname == this.imageFeatureName) {
              continue;
            }
            let v = this.dataPointValueFromFeature_(
              featureRoot.feature[fname],
              true
            );
            if (v != null) {
              d[fname] = v;
            }
          }

          // For sequence examples, extract the sequence feature values.
          const featureLists =
            'featureLists' in example
              ? Object.keys(example.featureLists.featureList)
              : [];
          for (const index in featureLists) {
            const fname = featureLists[+index];
            const fList = example.featureLists.featureList[fname].feature;
            let v = [];
            // Concatenate feature values from all values in the sequence for
            // each feature.
            for (let i = 0; i < fList.length; i++) {
              const newV = this.dataPointValueFromFeature_(fList[i], false);
              if (newV) {
                v = v.concat(newV);
              }
            }
            d[fname] = v;
          }
          d[exampleIdKey] = index;
          return d;
        },

        getExamplesAndCloseSettings_: function() {
          this.settingsClicked_();
          this.updateNumberOfModels();
          this.getExamples_();
        },

        showModelNumbers_: function() {
          return this.numModels <= 1;
        },

        /**
         * Callback for when new examples are received from the backend.
         */
        updateExampleContents: function(examples, hasSprite) {
          this.exampleStatusStr = examples.length + ' datapoints loaded';
          this.$.noexamples.style.display = 'none';
          this.spinnerHidden_ = true;
          this.examplesAndInferences = examples.map(function(ex) {
            const example = JSON.parse(ex);
            return {example: example, changed: false, orig: JSON.parse(ex)};
          });
          this.updatedExample = true;
          const self = this;
          this.visdata = this.examplesAndInferences.map(function(ex, i) {
            return self.exampleToDataPoint_(ex.example, i);
          });
          this.$.dive.atlasUrl = '';
          this.$.dive.imageFieldName = '';
          this.hasSprite = hasSprite;
          this.refreshDive_();
          if (
            !this.shouldDisableInferButton_(
              this.examplesAndInferences,
              this.modelName,
              this.inferenceAddress,
              this.updatedExample
            )
          ) {
            this.inferClicked_();
          }
          this.setInferenceFromExampleData();
        },

        /**
         * If the example data contains inference results, as in the case with
         * pre-computed model results, then set the appropriate inference results.
         */
        setInferenceFromExampleData: function() {
          // If the examples contain the classification results or regression
          // results keys, then set the classification results from the
          // information in the examples.
          if (this.visdata.length > 0) {
            if (this.visdata[0][classificationResultsKey] != null) {
              const inferences = {};
              const indices = Array.apply(null, {
                length: this.visdata.length,
              }).map(Number.call, Number);
              inferences.indices = indices;
              inferences.results = [
                {classificationResult: {classifications: []}},
              ];
              for (let i = 0; i < indices.length; i++) {
                inferences.results[0].classificationResult.classifications[
                  i
                ] = {
                  classes: [
                    {
                      label: '0',
                      score: this.visdata[i][classificationResultsKey][0],
                    },
                    {
                      label: '1',
                      score: this.visdata[i][classificationResultsKey][1],
                    },
                  ],
                };
              }
              this.inferences = inferences;
            } else if (this.visdata[0][regressionResultsKey] != null) {
              const inferences = {};
              const indices = Array.apply(null, {
                length: this.visdata.length,
              }).map(Number.call, Number);
              inferences.indices = indices;
              inferences.results = [{regressionResult: {regressions: []}}];
              for (let i = 0; i < indices.length; i++) {
                inferences.results[0].regressionResult.regressions[i] = {
                  value: this.visdata[i][regressionResultsKey],
                };
              }
              this.inferences = inferences;
            }
          }
        },

        getExamples_: function() {
          var url = this.makeUrl_('/data/plugin/whatif/examples_from_path', {
            examples_path: this.examplesPath,
            max_examples: this.maxExamples,
            sampling_odds: this.samplingOdds,
            sequence_examples: this.sequenceExamples,
          });

          const updateExampleContents = (result) => {
            this.updateExampleContents(
              result.value.examples,
              result.value.sprite
            );
          };
          this.exampleStatusStr = 'Loading datapoints...';
          this.makeAsyncRequest_(
            url,
            updateExampleContents,
            null,
            'datapoint load'
          );
          this.spinnerHidden_ = false;
        },

        updateSprite: function() {
          if (this.hasSprite) {
            this.$.dive.atlasUrl = null;
            if (!this.local) {
              this.$.dive.atlasUrl = this.makeUrl_(
                '/data/plugin/whatif/sprite',
                {}
              );
            } else {
              this.$.dive.atlasUrl = this.localAtlasUrl;
            }
          }
        },

        selectedDataUpdated_: function() {
          this.selectedExampleNum =
            this.selected.length > 0 ? this.selected[0] : '';
          if (this.visdata && this.visdata.length > 0) {
            this.partialDepPlotPendingFeatures = [];
          }
        },

        /**
         * Handler for copying a datapoint to a new datapoint.
         */
        copyDatapoint_: function() {
          const exampleJsonString = JSON.stringify(
            this.selectedExampleAndInference.example
          );
          const example = JSON.parse(exampleJsonString);
          const exampleAndInference = {
            example: example,
            changed: false,
            orig: JSON.parse(exampleJsonString),
          };
          this.examplesAndInferences.push(exampleAndInference);
          this.selectedExampleAndInference = exampleAndInference;
          this.visdata.push(
            this.exampleToDataPoint_(
              exampleAndInference.example,
              this.visdata.length
            )
          );
          const duplicatedIndex = this.selected[0];

          this.showNearestCounterfactual = false;

          // Automatically select the new datapoint.
          this.selected[0] = this.visdata.length - 1;
          this.selectedDataUpdated_();

          this.updatedExample = true;

          // Inform the backend of the new example.
          this.fire('duplicate-example', {index: duplicatedIndex});
          if (!this.local) {
            const refreshDiveAfterDuplicate = (result) => {
              this.refreshDive_();
            };
            const url = this.makeUrl_('/data/plugin/whatif/duplicate_example', {
              index: duplicatedIndex,
            });
            this.makeAsyncRequest_(
              url,
              refreshDiveAfterDuplicate,
              null,
              'datapoint duplication'
            );
          } else {
            this.refreshDive_();
          }
        },

        deleteDatapointDialog_: function() {
          this.$.deletedialog.open();
        },

        /**
         * Handler for deleting a datapoint.
         */
        deleteDatapoint_: function() {
          // Remove the datapoint, unselect it, and inform the backend.
          const deletedIndex = this.selected[0];
          this.examplesAndInferences.splice(deletedIndex, 1);
          this.visdata.splice(deletedIndex, 1);

          // Fix example IDs due to deleted index.
          for (let i = deletedIndex; i < this.visdata.length; i++) {
            this.visdata[i][exampleIdKey] = i;
          }

          this.comparedIndices = [];
          this.selected = [];
          this.selectedDataUpdated_();
          this.fire('delete-example', {index: deletedIndex});
          this.$.dive.selectedIndices = [];
          if (!this.local) {
            const refreshDiveAfterDelete = (result) => {
              this.refreshDive_();
            };
            const url = this.makeUrl_('/data/plugin/whatif/delete_example', {
              index: deletedIndex,
            });
            this.makeAsyncRequest_(
              url,
              refreshDiveAfterDelete,
              null,
              'datapoint delete'
            );
          } else {
            this.refreshDive_();
          }
        },

        shouldDisableReset_: function(exampleChanged) {
          return !exampleChanged;
        },

        /**
         * Handler for resetting an edited datapoint.
         */
        resetDatapoint_: function() {
          // Force reset of example in example viewer component by clearing out
          // the example and then waiting a frame to set it back to the original
          // value.
          this.set('selectedExampleAndInference.example', {});

          requestAnimationFrame(() => {
            this.selectedExampleAndInference.changed = false;
            const origExampleJsonString = JSON.stringify(
              this.selectedExampleAndInference.orig
            );
            this.set(
              'selectedExampleAndInference.example',
              JSON.parse(origExampleJsonString)
            );
            this.visdata[this.selected[0]] = this.exampleToDataPoint_(
              this.selectedExampleAndInference.example,
              this.selected[0]
            );
            this.updatedExample = true;
            this.updateExample_(origExampleJsonString, this.selected[0]);
            this.refreshDive_();
          });
        },

        /**
         * Add a partial dependence plot for a given feature.
         */
        addChart: function(chartType, featureName, data) {
          let chart;
          let dataToChart = data;

          // If multiclass and there are more inferred classes than the set
          // number of classes to display, then filter the classes to display
          // in the chart down to the top scoring classes.
          if (this.isMultiClass_(this.modelType, this.multiClass)) {
            dataToChart = [];
            for (let modelIdx = 0; modelIdx < data.length; modelIdx++) {
              let modelDataToChart = {};
              if (
                Object.keys(data[modelIdx]).length >
                Number(this.maxInferenceEntriesPerRun)
              ) {
                const exampleId =
                  this.selected && this.selected.length > 0
                    ? this.selected[0]
                    : 0;
                // Get the class labels of the top scoring classes from the most
                // recent inference.
                const currentExample = this.examplesAndInferences[exampleId];
                const lastInference =
                  currentExample.inferences[
                    currentExample.inferences.length - 1
                  ];
                const labels = lastInference[modelIdx].slice(
                  0,
                  this.maxInferenceEntriesPerRun
                );
                for (let labelIdx = 0; labelIdx < labels.length; labelIdx++) {
                  const label = labels[labelIdx].label;
                  modelDataToChart[label] = data[modelIdx][label];
                }
              } else {
                modelDataToChart = data[modelIdx];
              }
              dataToChart.push(modelDataToChart);
            }
          }

          if (chartType == 'numeric') {
            chart = this.makeLineChart(featureName, dataToChart);
          } else if (chartType == 'categorical') {
            chart = this.makeBarChart(featureName, dataToChart);
          } else {
            console.error('Unknown chartType: ' + chartType);
          }

          const container = this.featureContainerByName(featureName);

          // Append chart
          const categoryPane = container.querySelector(
            '.tf-category-pane-content'
          );
          Polymer.dom(categoryPane).appendChild(chart);

          // Remove the feature from pending queue, so it can be called again.
          const feature_ind = this.partialDepPlotPendingFeatures.indexOf(
            featureName
          );
          if (feature_ind > -1) {
            this.partialDepPlotPendingFeatures.splice(feature_ind, 1);
          }
        },

        getSimpleAxisFormatter: function(precision) {
          return Plottable.Formatters.general(precision);
        },

        makeBarChart: function(featureName, data) {
          // array of categorical data objects (keys are labels):
          // {"1": [{"step": ["Divorced"], "scalar": 0.1533520370721},
          //    {"step": ["Married-AF-spouse"], "scalar": 0.153403326869}]},
          // one object per model

          function convertPoint(point, origKey) {
            // point: {"step": ["Divorced"], "scalar": 0.1533520370721817}
            return {
              x:
                point.step == origKey
                  ? point.step + ' - original value'
                  : point.step,
              y: point.scalar,
            };
          }

          function convertThreshold(point, origKey, threshold) {
            return {
              x:
                point.step == origKey
                  ? point.step + ' - original value'
                  : point.step,
              scalar: point.scalar,
              y: threshold,
            };
          }

          // Overwrite the key for original value so that it reads under the bar
          let origKey = '';
          const firstModelValues = data[0];
          if (!this.globalPdPlots) {
            const origValEntry = this.createPdEntryForCurrentValue(
              featureName,
              firstModelValues,
              0
            );
            if (origValEntry) {
              origKey = origValEntry.step;
            }
          }

          // Convert the data into the format expected by vz-bar-chart.
          // Stack models and labels so that each (model,label) is a separate
          // series
          const lines = {};
          const mapped = {};
          const self = this;
          _.forEach(data, (modelValues, modelInd) => {
            const obj = _.forEach(modelValues, (pointsForSeries, labelKey) => {
              // Sort bars by their inference values for display.
              mapped[
                this.formatChartKey(labelKey, modelInd, data.length)
              ] = _.map(pointsForSeries, (point) =>
                convertPoint(point, origKey)
              ).sort((a, b) => b.y - a.y);
              // For binary classifiers, also create lines to indicate the
              // classification threshold for each model, with datapoints
              // sorted by the inference values to match the bar order for
              // the bar chart it will be displayed over.
              if (
                this.isBinaryClassification_(this.modelType, this.multiClass)
              ) {
                lines[
                  this.formatChartKey(labelKey, modelInd, data.length)
                ] = _.map(pointsForSeries, (point) =>
                  convertThreshold(
                    point,
                    origKey,
                    this.overallThresholds[modelInd].threshold
                  )
                ).sort((a, b) => b.scalar - a.scalar);
              }
            });
          });

          const valueFormatter = vz_chart_helpers.multiscaleFormatter(
            vz_chart_helpers.Y_TOOLTIP_FORMATTER_PRECISION
          );
          const toolTipColumns = [
            {
              title: 'Inference value',
              evaluate: (d) => {
                const splitLabel = this.splitChartKey(d.key, data.length);
                let label = splitLabel.label;
                if (!isNaN(label) && label.length > 0 && this.labelVocab) {
                  const index = +label;
                  if (index < this.labelVocab.length && index >= 0) {
                    label += ' (' + this.labelVocab[index] + ')';
                  }
                }
                return label;
              },
            },
            {
              title: 'Feature value',
              evaluate: (d) => d.value.x,
            },
            {
              title: 'Score',
              evaluate: (d) => valueFormatter(d.value.y),
            },
          ];
          // If there is more than 1 model, show model number tooltip
          if (data.length >= 2) {
            toolTipColumns.push({
              title: 'Model',
              evaluate: (d) => {
                const label = this.splitChartKey(d.key, data.length);
                return label.model;
              },
            });
          }

          const holder = document.createElement('div');
          holder.classList.add('pd-holder');
          const chart = document.createElement('vz-bar-chart');
          chart.colorScale = new Plottable.Scales.Color().range(
            this.pdPlotColors
          );
          chart.linesColorScale = new Plottable.Scales.Color().range(
            this.pdPlotTransparentColors
          );
          chart.data = mapped;
          chart.lines = lines;
          chart.tooltipColumns = toolTipColumns;
          holder.appendChild(chart);

          const yLabel = document.createElement('div');
          yLabel.classList.add('pd-y-label');
          yLabel.innerText = this.isRegression_(this.modelType)
            ? 'Inference value'
            : 'Inference score';
          holder.appendChild(yLabel);

          return holder;
        },

        splitChartKey: function(labelKey, numberOfModels) {
          // If there is model key split it, otherwise just return original
          // label (index i) (model m) -> label (index #), m
          let keyToChart = labelKey;
          let modelToChart = '';
          if (numberOfModels >= 2) {
            const indexOfModelStr = labelKey.indexOf('(model');
            keyToChart = labelKey.substring(0, indexOfModelStr);
            modelToChart = labelKey.substring(
              indexOfModelStr + 7,
              labelKey.lastIndexOf(')')
            );
          }
          return {label: keyToChart, model: modelToChart};
        },

        formatChartKey: function(labelKey, modelInd, numberOfModels) {
          if (numberOfModels == 1) {
            return labelKey;
          } else {
            return labelKey + ' (model ' + this.getModelName_(modelInd) + ')';
          }
        },

        makeLineChart: function(featureName, data) {
          // numerical data:
          // {"0" (model id):
          //     {"1" (label): [{"step": 19.0, "scalar": 0.09157766401767},
          //        {"step": 23.444444444444443, "scalar": 0.10299546271562}]}}

          const holder = document.createElement('div');
          holder.classList.add('pd-holder');
          const chart = document.createElement('vz-line-chart2');
          const colorScale = [];
          const thresholdSeries = [];
          const valueFormatter = vz_chart_helpers.multiscaleFormatter(
            vz_chart_helpers.Y_TOOLTIP_FORMATTER_PRECISION
          );
          const formatValueOrNaN = function(x) {
            return Number.isNaN(x) ? 'NaN' : valueFormatter(x);
          };
          if (this.modelType == 'classification') {
            chart.defaultYRange = [0, 1];
          }
          const toolTipColumns = [
            {
              title: 'Inference value',
              evaluate: (d) => {
                const splitLabel = this.splitChartKey(
                  d.dataset.metadata().name,
                  data.length
                );
                let label = splitLabel.label;
                if (!isNaN(label) && label.length > 0 && this.labelVocab) {
                  const index = +label;
                  if (index < this.labelVocab.length && index >= 0) {
                    label += ' (' + this.labelVocab[index] + ')';
                  }
                }
                return label;
              },
            },
            {
              title: 'Feature value',
              evaluate: (d) => formatValueOrNaN(d.datum.step),
            },
            {
              title: 'Score',
              evaluate: (d) => formatValueOrNaN(d.datum.scalar),
            },
          ];
          // If there is more than 1 model, show model number tooltip
          if (data.length >= 2) {
            toolTipColumns.push({
              title: 'Model',
              evaluate: (d) => {
                const label = this.splitChartKey(
                  d.dataset.metadata().name,
                  data.length
                );
                return label.model;
              },
            });
          }
          chart.tooltipColumns = toolTipColumns;

          const allSeries = [];
          let colorIndex = 0;
          for (let modelInd = 0; modelInd < data.length; modelInd++) {
            const modelData = data[modelInd];
            const series = _.keys(modelData);
            colorIndex = modelInd * series.length;
            series.forEach((label) => {
              colorScale.push(this.pdPlotColors[colorIndex++]);
              const thisLabel = this.formatChartKey(
                label,
                modelInd,
                data.length
              );
              chart.setSeriesData(thisLabel, modelData[label]);
              allSeries.push(thisLabel);
            });
            // Make a series for the current value of the feature to show in the
            // plot.
            colorIndex = modelInd * series.length;
            if (!this.globalPdPlots) {
              const origValEntry = this.createPdEntryForCurrentValue(
                featureName,
                modelData,
                modelInd
              );
              if (origValEntry) {
                const showKey = this.formatChartKey(
                  _.keys(modelData)[0] + ' - original value ',
                  modelInd,
                  data.length
                );
                chart.setSeriesData(showKey, [origValEntry]);
                allSeries.push(showKey);
                colorScale.push(this.pdPlotColors[colorIndex].brighter());
              }
            }
            if (this.isBinaryClassification_(this.modelType, this.multiClass)) {
              const label = this.formatChartKey(
                'classification threshold',
                modelInd,
                data.length
              );
              const thresholdData = data[0][_.keys(data[0])].map((point) => {
                return {
                  step: point.step,
                  scalar: this.overallThresholds[modelInd].threshold,
                };
              });
              colorScale.push(this.pdPlotTransparentColors[colorIndex]);
              chart.setSeriesData(label, thresholdData);
              thresholdSeries.push(label);
              allSeries.push(label);
            }
          }
          chart.colorScale = new Plottable.Scales.Color().range(colorScale);
          chart.xAxisFormatter = this.getSimpleAxisFormatter(
            this.axisPrecision
          );
          chart.yAxisFormatter = this.getSimpleAxisFormatter(
            this.axisPrecision
          );
          // Do not show tooltips for the lines indicating model threshold values.
          chart.seriesWithoutTooltips = thresholdSeries;
          chart.colorScale.domain(allSeries);
          chart.setVisibleSeries(allSeries);
          holder.appendChild(chart);

          const yLabel = document.createElement('div');
          yLabel.classList.add('pd-y-label');
          yLabel.innerText = this.isRegression_(this.modelType)
            ? 'Inference value'
            : 'Inference score';
          holder.appendChild(yLabel);
          const xLabel = document.createElement('div');
          xLabel.classList.add('pd-x-label');
          xLabel.innerText = featureName;
          holder.appendChild(xLabel);

          return holder;
        },

        /**
         * Helper for making a partial dependence plot entry for the current
         * value for a feature.
         */
        createPdEntryForCurrentValue: function(featureName, data, modelInd) {
          // Extract the class and feature value index from the key of the PD
          // chart data .
          const key = _.keys(data)[0];
          const indexOfIndexStr = key.indexOf('index');
          let classToChart = +key;
          let indexForValue = 0;
          if (indexOfIndexStr > -1) {
            classToChart = +key.substring(0, key.indexOf(' '));
            indexForValue = +key.substring(
              indexOfIndexStr + 6,
              key.indexOf(')')
            );
          }

          let origValue = this.visdata[this.selected[0]][featureName];
          if (Array.isArray(origValue)) {
            origValue = origValue[indexForValue];
          }

          const inferences = this.selectedExampleAndInference.inferences[
            this.selectedExampleAndInference.inferences.length - 1
          ][modelInd];
          let origInferenceScore = -1;
          for (let i = 0; i < inferences.length; i++) {
            if (
              inferences[i].label == classToChart.toString() ||
              inferences[i].label == ''
            ) {
              origInferenceScore = inferences[i].score;
              break;
            }
          }
          if (origInferenceScore == -1) {
            return null;
          }
          return {step: origValue, scalar: origInferenceScore};
        },

        deletePdPlotSpinner: function(featureName) {
          const container = this.featureContainerByName(featureName);
          deleteElement(container.querySelector('paper-spinner-lite'));
        },

        makeChartForFeature: function(chartType, featureName, data) {
          this.deletePdPlotSpinner(featureName);
          // A separate chart per feature index for features with multiple values
          data.forEach((subfeature) =>
            this.addChart(chartType, featureName, subfeature)
          );
        },

        /**
         * Handler for getting partial dependence plot information for a given
         * feature.
         */
        getInferenceVisualization: function(featureName, event) {
          // The range of x-values to interpolate over for numerical features.
          const xMin = this.getUniqueByEvent(event, '.x-min').value;
          const xMax = this.getUniqueByEvent(event, '.x-max').value;

          // For a numerical feature with many repeated values, we allow users to
          // restrict inference to a smaller range of indices by using a pattern
          // (e.g. "0,2,4-6" runs inference for indices 0, 2, 4, 5, 6).
          const featureIndexPattern = this.getUniqueByEvent(
            event,
            '.feature-index-pattern'
          ).value;

          const urlParams = {
            feature_name: featureName,
            inference_address: this.inferenceAddress,
            model_name: this.modelName,
            model_type: this.modelType,
            model_version: this.modelVersion,
            model_signature: this.modelSignature,
            x_min: xMin,
            x_max: xMax,
            feature_index_pattern: featureIndexPattern,
            example_index: this.globalPdPlots ? -1 : this.selected[0],
            use_predict: this.usePredictApi,
            predict_output_tensor: this.predictOutputTensor,
            predict_input_tensor: this.predictInputTensor,
          };

          // Call into backend.
          if (!this.local) {
            const url = tf_backend.addParams(
              '/data/plugin/whatif/infer_mutants',
              urlParams
            );
            const chartMakerCallback = (result) => {
              return this.makeChartForFeature(
                result.value.chartType,
                featureName,
                result.value.data
              );
            };
            const chartErrorCallback = () => {
              return this.handleChartErrorForFeature(featureName);
            };
            this.makeAsyncRequest_(
              url,
              chartMakerCallback.bind(this),
              null,
              'plot creation',
              chartErrorCallback.bind(this)
            );
          } else {
            this.fire('infer-mutants', urlParams);
          }

          // Show a spinner while the plot is being calculated.
          const container = this.featureContainerByName(
            featureName
          ).querySelector('.tf-category-pane-content');
          const spinner = document.createElement('paper-spinner-lite');
          spinner.setAttribute('active', true);
          Polymer.dom(container).appendChild(spinner);
        },

        handleChartErrorForFeature: function(featureName) {
          // Remove the feature from pending queue, so it can be called again.
          const featureInd = this.partialDepPlotPendingFeatures.indexOf(
            featureName
          );
          if (featureInd > -1) {
            this.partialDepPlotPendingFeatures.splice(featureInd, 1);
          }
          // Delete the spinner.
          this.deletePdPlotSpinner(featureName);
        },

        shouldHideFeatureIndicesSelector: function(featureName, selected) {
          if (
            !selected ||
            selected.length == 0 ||
            !this.visdata ||
            this.visdata.length <= selected[0]
          ) {
            return true;
          }
          const item = this.visdata[selected[0]];
          return !Array.isArray(item[featureName]);
        },

        /** Check if pd-input-container has any elements in it and hide it if it
        does not*/
        shouldHidePdInputContainer: function(item, selected) {
          if (
            !this.shouldHideFeatureIndicesSelector(item.name, selected) ||
            !item.samples
          ) {
            return false;
          } else {
            return true;
          }
        },

        /** Returns the feature container associated with the feature name. */
        featureContainerByName: function(featureName) {
          return this.$$('[data-feature-name="' + featureName + '"]');
        },

        /** Return the feature container associated with the specific event. */
        featureContainerByEvent: function(event) {
          let el = event.target;
          while (!el.classList.contains('feature-container')) {
            el = el.parentNode;
          }
          return el;
        },

        /** Gets the selector within .feature-container for the event. */
        getUniqueByEvent(event, selector) {
          return this.featureContainerByEvent(event).querySelector(selector);
        },

        partialDepPlotEligibleFeaturesSet: function(features) {
          this.isSortingEligibleFeatures = false;
          if (!features || features.length == 0) {
            return;
          }
          // Open up the first PD plot pane after the category panes have loaded.
          setTimeout(() => {
            if (this.$$('.pd-entry-container').hidden) {
              this.$$('.tf-category-pane').click();
            }
          }, 100);
        },

        /**
         * Handler for click on button to generate partial dependence plots for
         * a feature.
         */
        categoryPaneClicked: function(event) {
          const featureContainer = this.featureContainerByEvent(event);

          const element = featureContainer.querySelector('.pd-entry-container');

          if (element.hasAttribute('hidden')) {
            this.drawPdCharts_(event);
            this.showPdElement_(featureContainer);
          } else {
            this.hidePdElement_(featureContainer);
          }
        },

        /**
         * Handler for drawing partial dependence plots for a feature.
         */
        drawPdCharts_: function(event) {
          // Make sure the feature wasn't already requested.
          const featureName = event.model.get('item').name;
          if (this.partialDepPlotPendingFeatures.indexOf(featureName) > -1) {
            return;
          }
          this.partialDepPlotPendingFeatures.push(featureName);

          this.getInferenceVisualization(featureName, event);
        },

        /**
         * Handler for clearing the partial dependence plots for a feature.
         */
        clearPdElementCharts_: function(element) {
          // Delete all the charts.
          const charts = element.querySelectorAll('.pd-holder');
          charts.forEach(function(chart) {
            deleteElement(chart);
          });
        },

        /**
         * Handler for closing the partial dependence plots holder for a feature.
         */
        hidePdElement_: function(featureContainer) {
          // Clear the plots
          const element = featureContainer.querySelector('.pd-entry-container');
          this.clearPdElementCharts_(element);
          element.setAttribute('hidden', true);
          // Handle icon
          const icon = featureContainer.querySelector('.pd-row-arrow');
          icon.classList.remove('normal-icon');
          icon.classList.add('rotated-icon');
          // Handle row style
          const row = featureContainer.querySelector('.perf-table-entry');
          row.classList.add('perf-table-row');
          row.classList.remove('perf-table-row-expanded');
        },

        showPdElement_: function(featureContainer) {
          const element = featureContainer.querySelector('.pd-entry-container');
          element.removeAttribute('hidden');
          // Handle icon
          const icon = featureContainer.querySelector('.pd-row-arrow');
          icon.classList.add('normal-icon');
          icon.classList.remove('rotated-icon');
          // Handle row style
          const row = featureContainer.querySelector('.perf-table-entry');
          row.classList.remove('perf-table-row');
          row.classList.add('perf-table-row-expanded');
        },

        hideAllPdElements_: function() {
          const elements = Polymer.dom(this.root).querySelectorAll(
            '.feature-container'
          );
          for (let i = 0; i < elements.length; i++) {
            this.hidePdElement_(elements[i]);
          }
        },

        pdInputChanged: function(event) {
          // Debounce a refresh request, for when multiple updates are happening
          // in succession.
          this.debounce(
            'pdInputChangedDebounce',
            () => this.pdInputChangedImpl(event),
            500
          );
        },

        /**
         * Handler for changes in settings for a partial dependence plot.
         */
        pdInputChangedImpl: function(event) {
          // Hide all existing plots so they can be regenerated with the new
          // settings.
          const element = this.getUniqueByEvent(
            event,
            '.tf-category-pane-content'
          );
          this.clearPdElementCharts_(element);
          // Draw new plots
          this.drawPdCharts_(event);
        },

        /**
         * Populates the partial dependence plots area for a selected example.
         */
        populatePdTabs: function() {
          // First hide all existing PD plots before refreshing.
          this.hideAllPdElements_();

          // Call into the backend to get the possible features to show plots for.
          if (!this.local) {
            const url = tf_backend.addParams(
              '/data/plugin/whatif/eligible_features',
              {}
            );
            const setEligibleFields = (result) => {
              this.set('partialDepPlotEligibleFeatures', result.value);
            };
            this.makeAsyncRequest_(url, setEligibleFields, null, 'plot setup');
          } else {
            this.fire('get-eligible-features');
          }
        },

        sortPdFeatures_: function() {
          // First hide all existing PD plots before refreshing.
          this.hideAllPdElements_();
          const urlParams = {
            example_index: this.globalPdPlots ? -1 : this.selected[0],
            inference_address: this.inferenceAddress,
            model_name: this.modelName,
            model_type: this.modelType,
            model_version: this.modelVersion,
            model_signature: this.modelSignature,
            use_predict: this.usePredictApi,
            predict_output_tensor: this.predictOutputTensor,
            predict_input_tensor: this.predictInputTensor,
          };
          this.isSortingEligibleFeatures = true;
          // Call into the backend to sort the possible features to show plots for.
          if (!this.local) {
            const url = tf_backend.addParams(
              '/data/plugin/whatif/sort_eligible_features',
              urlParams
            );
            const setEligibleFields = (result) => {
              this.set('partialDepPlotEligibleFeatures', result.value);
            };
            const sortErrorCallback = () => {
              this.isSortingEligibleFeatures = false;
            };
            this.makeAsyncRequest_(
              url,
              setEligibleFields,
              null,
              'plot ordering',
              sortErrorCallback.bind(this)
            );
          } else {
            urlParams['features'] = this.partialDepPlotEligibleFeatures;
            this.fire('sort-eligible-features', urlParams);
          }
        },
        shouldDisableSortFeaturesButton: function(
          partialDepPlotEligibleFeatures,
          isSortingEligibleFeatures
        ) {
          // Do not show "sort features by interestingness" button if sorting is
          // currently occuring or there are no features to sort.
          return (
            isSortingEligibleFeatures ||
            partialDepPlotEligibleFeatures == null ||
            partialDepPlotEligibleFeatures.length == 0
          );
        },

        toggleTrueLabelSetup: function() {
          this.$.collapsetruelabel.toggle();
        },

        toggleExplorerSetup: function() {
          this.$$('#collapseexplorer').toggle();
        },

        toggleContextTools: function() {
          this.$.collapsecontexttools.toggle();
        },

        togglePerformance: function() {
          this.$.collapseperformance.toggle();
        },

        toggleInferenceResults: function() {
          this.$$('#collapseinference').toggle();
        },

        getExpandCollapseIcon: function(opened) {
          return opened ? 'expand-less' : 'expand-more';
        },

        getExpandCollapsePerfIconClass: function(opened) {
          return opened ? 'normal-icon' : 'rotated-icon';
        },

        getPerfTableRowClass: function(opened) {
          return opened ? 'perf-table-row-expanded' : 'perf-table-row';
        },

        getPerfTableModelClass: function(numModels) {
          return numModels < 2 ? 'perf-table-model-single' : 'perf-table-model';
        },

        getDatapointEditorTitle: function(selectedExampleNum, comparedIndices) {
          return this.getSectionTitle(
            'Edit',
            selectedExampleNum,
            comparedIndices
          );
        },

        getInferTitle: function(selectedExampleNum, comparedIndices) {
          return this.getSectionTitle(
            'Infer',
            selectedExampleNum,
            comparedIndices
          );
        },

        getSectionTitle: function(title, selectedExampleNum, comparedIndices) {
          let name = title;
          if (selectedExampleNum != null && selectedExampleNum !== '') {
            if (comparedIndices != null && comparedIndices.length > 0) {
              name +=
                ' - Datapoints ' +
                selectedExampleNum +
                ' and ' +
                comparedIndices[0];
            } else {
              name += ' - Datapoint ' + selectedExampleNum;
            }
          }
          return name;
        },

        /**
         * Expands/collapses a row in the performance table based on a click.
         */
        togglePerfRow: function(event) {
          // Find the table index for which the click was made.
          let el = event.target;
          while (el != null && !el.dataset.index) {
            el = el.parentNode;
          }
          if (el == null) {
            return;
          }
          const index = el.dataset.index;

          // Toggle the appropriate 'opened' variable in the list
          // that backs the performance table.
          this.set(
            'featureValueThresholds.' + index + '.opened',
            !this.featureValueThresholds[index].opened
          );

          // If expanding a section, update inference stats to ensure
          // properly rendered ROC curve.
          if (this.featureValueThresholds[index].opened) {
            requestAnimationFrame(() => this.updateInferenceStats_(true));
          }
        },

        getPerformanceTabTitle: function(modelType, multiClass) {
          return this.isBinaryClassification_(modelType, multiClass)
            ? 'Performance & Fairness'
            : 'Performance';
        },

        getPerfTableTitle: function(
          feature1,
          feature2,
          optimization,
          thresholds
        ) {
          let str = this.getPrintableOptimizationName(optimization);
          if (feature1 == null || feature1.length == 0) {
            if (optimization == 'custom') {
              return 'Explore overall performance';
            } else {
              return str;
            }
          } else {
            let featStr = feature1;
            if (feature2 != null && feature2.length != 0) {
              featStr += '/' + feature2;
            }
            return str + ' for ' + thresholds.length + ' values of ' + featStr;
          }
        },

        getNoThresholdPerfTableTitle: function(feature1, feature2, thresholds) {
          if (feature1 == null || feature1.length == 0) {
            return 'Explore overall performance';
          } else {
            let str = feature1;
            if (feature2 != null && feature2.length != 0) {
              str += '/' + feature2;
            }
            return str + ' (' + thresholds.length + ' values)';
          }
        },

        getPrintableOptimizationName: function(optimization) {
          if (optimization == 'custom') {
            return 'Custom thresholds';
          } else if (optimization == 'unaware') {
            return 'Optimal single threshold';
          } else if (optimization == 'demoparity') {
            return 'Demographic parity thresholds';
          } else if (optimization == 'equalopp') {
            return 'Equal opportunity thresholds';
          } else if (optimization == 'equalacc') {
            return 'Equal accuracy thresholds';
          } else {
            return 'Optimal group thresholds';
          }
        },

        getFeatureSortBy: function(modelType, multiClass) {
          let sorts = ['Count', 'Alphabetical'];
          if (this.isBinaryClassification_(modelType, multiClass)) {
            sorts = sorts.concat([
              'Accuracy',
              'False positives',
              'False negatives',
            ]);
          } else if (this.isMultiClass_(modelType, multiClass)) {
            sorts = sorts.concat(['Accuracy']);
          } else {
            sorts = sorts.concat([
              'Mean error',
              'Median error',
              'Mean absolute error',
              'Median absolute error',
              'Mean squared error',
              'Median squared error',
            ]);
          }
          return sorts;
        },

        selectedFeatureSortChanged_: function(sort) {
          const temp = this.featureValueThresholds;
          this.featureValueThresholds = [];
          this.featureValueThresholds = this.sortFeatureValues(temp);

          if (this.regressionEntries_ != null) {
            const temp = this.regressionEntries_;
            this.regressionEntries_ = [];
            this.regressionEntries_ = this.sortRegressionEntries(temp);
          }
        },

        getSliderClass: function(index) {
          let str = 'slider ';
          str += index == 0 ? 'slider-model-one' : 'slider-model-two';
          return str;
        },

        formatError: function(error) {
          return d3.format('.3f')(error);
        },

        expandAllPerformance: function() {
          if (this.featureValueThresholds == null) {
            return;
          }
          for (let i = 0; i < this.featureValueThresholds.length; i++) {
            this.set('featureValueThresholds.' + i + '.opened', true);
          }
          requestAnimationFrame(() => this.updateInferenceStats_(true));
        },

        collapseAllPerformance: function() {
          if (this.featureValueThresholds == null) {
            return;
          }
          for (let i = 0; i < this.featureValueThresholds.length; i++) {
            this.set('featureValueThresholds.' + i + '.opened', false);
          }
        },

        getPerfTableEntryClass: function(eligibleFeature) {
          let str = 'perf-table-entry perf-table-row ';
          // If interestingness is set to 0 then display this feature as
          // trivial.
          if (
            'interestingness' in eligibleFeature &&
            eligibleFeature['interestingness'] == 0
          ) {
            str += 'perf-table-entry-trivial';
          }
          return str;
        },
      });

      // TODO(#2338): Remove this, and set up a "no TF" message properly.
      // Keep this in sync with `frontend_metadata` in
      // `interactive_inference_plugin.py`.
      tf_tensorboard.registerDashboard({
        plugin: PLUGIN_NAME,
        elementName: 'tf-interactive-inference-dashboard',
        tabName: 'What-If Tool',
      });
    })();
  </script>
</dom-module>
